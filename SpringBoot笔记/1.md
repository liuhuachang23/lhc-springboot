​	

## 一、基础入门

### 1. 课程介绍

1)Spring Boot 2核心技术

2)Spring Boot 2响应式编程

  学习要求

- 熟悉Spring基础
- 熟悉Maven使用

  环境要求
- Java8及以上
- Maven 3.3及以上

  学习资料
- [Spring Boot官网](https://spring.io/projects/spring-boot)
- [Spring Boot官方文档](https://docs.spring.io/spring-boot/docs/)
- [本课程文档地址](https://www.yuque.com/atguigu/springboot)
- [视频地址1](http://www.gulixueyuan.com/)、[视频地址2](https://www.bilibili.com/video/BV19K4y1L7MT?p=1)
- [源码地址](https://gitee.com/leifengyang/springboot2)



### 2. Spring生态圈

[Spring官网](https://spring.io/)



#### 1）Spring能做什么



![在这里插入图片描述](image/20210205004146543.png)



#### 2）Spring的生态

覆盖了：

- web开发
- 数据访问
- 安全控制
- 分布式
- 消息服务
- 移动开发
- 批处理
- ......



#### 3） Spring5重大升级

- 响应式编程

![在这里插入图片描述](image/20210205004250581.png)

- 内部源码设计

	基于Java8的一些新特性，如：接口默认实现。重新设计源码架构。



#### 4）为什么用SpringBoot

> Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can "just run".[link](https://spring.io/projects/spring-boot)
> 
> 能快速创建出生产级别的Spring应用。

#### 5）SpringBoot优点

- Create stand-alone Spring applications
	- 创建独立Spring应用
- Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)
	- 内嵌web服务器
- Provide opinionated 'starter' dependencies to simplify your build configuration
	- 自动starter依赖，简化构建配置
- Automatically configure Spring and 3rd party libraries whenever possible
	- 自动配置Spring以及第三方功能
- Provide production-ready features such as metrics, health checks, and externalized configuration
	- 提供生产级别的监控、健康检查及外部化配置
- Absolutely no code generation and no requirement for XML configuration
	- 无代码生成、无需编写XML


- SpringBoot是整合Spring技术栈的一站式框架
- SpringBoot是简化Spring技术栈的快速开发脚手架


#### 6）SpringBoot缺点

- 人称版本帝，迭代快，需要时刻关注变化

- 封装太深，内部原理复杂，不容易精通

	

### 3. 大时代背景



#### 1）微服务

> In short, the **microservice architectural style** is an approach to developing a single application as a **suite of small services**, each **running in its own process** and communicating with **lightweight** mechanisms, often an **HTTP** resource API. These services are built around **business capabilities** and **independently deployable** by fully **automated deployment** machinery. There is a bare minimum of centralized management of these services, which may be **written in different programming languages** and use different data storage technologies.——[James Lewis and Martin Fowler (2014)](https://martinfowler.com/articles/microservices.html)

- 微服务是一种架构风格
- 一个应用拆分为一组小型服务
- 每个服务运行在自己的进程内，也就是可独立部署和升级
- 服务之间使用轻量级HTTP交互
- 服务围绕业务功能拆分
- 可以由全自动部署机制独立部署
- 去中心化，服务自治。服务可以使用不同的语言、不同的存储技术

#### 2）分布式
![在这里插入图片描述](image/2021020500434620.png)

##### ① 分布式的困难

- 远程调用
- 服务发现
- 负载均衡
- 服务容错
- 配置管理
- 服务监控
- 链路追踪
- 日志管理
- 任务调度
- ......

##### ② 分布式的解决

- SpringBoot + SpringCloud

![在这里插入图片描述](image/20210205004523307.png)

#### 3）云原生

原生应用如何上云。 Cloud Native

##### ① 上云的困难

- 服务自愈
- 弹性伸缩
- 服务隔离
- 自动化部署
- 灰度发布
- 流量治理
- ......

##### ② 上云的解决

![在这里插入图片描述](image/20210205004621290.png)


### 4. 官方文档架构

- [Spring Boot官网](https://spring.io/projects/spring-boot)
- [Spring Boot官方文档](https://docs.spring.io/spring-boot/docs/)

#### 官网文档架构
![在这里插入图片描述](image/20210205004733270.png)
![在这里插入图片描述](image/20210205004828702.png)

[查看版本新特性](https://github.com/spring-projects/spring-boot/wiki#release-notes)

![在这里插入图片描述](image/20210205005342147.png)



### 5. HelloWorld



#### 1）系统要求

- Java 8
- Maven 3.3+
- IntelliJ IDEA 2019.1.2

#### 2）Maven配置文件

新添内容：

```xml
<mirrors>
	<mirror>
		<id>nexus-aliyun</id>
		<mirrorOf>central</mirrorOf>
		<name>Nexus aliyun</name>
		<url>http://maven.aliyun.com/nexus/content/groups/public</url>
	</mirror>
</mirrors>

<profiles>
	<profile>
		<id>jdk-1.8</id>

		<activation>
			<activeByDefault>true</activeByDefault>
			<jdk>1.8</jdk>
		</activation>

		<properties>
			<maven.compiler.source>1.8</maven.compiler.source>
			<maven.compiler.target>1.8</maven.compiler.target>
			<maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
		</properties>
	</profile>
</profiles>
```



#### 3）HelloWorld项目

需求：浏览发送/hello请求，响应 “Hello，Spring Boot 2”

##### ① 创建maven工程


##### ②引入依赖

```xml
<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-parent</artifactId>
	<version>2.3.4.RELEASE</version>
</parent>

<dependencies>
	<dependency>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-web</artifactId>
	</dependency>
</dependencies>
```

##### ③ 创建主程序

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MainApplication {

    public static void main(String[] args) {
        SpringApplication.run(MainApplication.class, args);
    }
}

```

##### ④ 编写业务

```java
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class HelloController {
    @RequestMapping("/hello")
    public String handle01(){
        return "Hello, Spring Boot 2!";
    }
}
```

##### ⑤ 运行&测试

- 运行`MainApplication`类
- 浏览器输入`http://localhost:8888/hello`，将会输出`Hello, Spring Boot 2!`。

##### ⑥ 设置配置

maven工程的resource文件夹中创建application.properties文件。

```properties
# 设置端口号
server.port=8888
```

[更多配置信息](https://docs.spring.io/spring-boot/docs/2.3.7.RELEASE/reference/html/appendix-application-properties.html#common-application-properties-server)



##### ⑦ 打包部署

在pom.xml添加

```xml
<build>
	<plugins>
		<plugin>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-maven-plugin</artifactId>
		</plugin>
	</plugins>
</build>
```

在IDEA的Maven插件上点击运行 clean 、package，把helloworld工程项目的打包成jar包，

打包好的jar包被生成在helloworld工程项目的target文件夹内。

用cmd运行`java -jar boot-01-helloworld-1.0-SNAPSHOT.jar`，既可以运行helloworld工程项目。

将jar包直接在目标服务器执行即可。



### 6. 依赖管理特性



#### 1) 父项目做依赖管理

```xml
<!--parent父项目做依赖管理
    它的作用是一般是来做依赖管理，父项目中可能会声明非常多的依赖，子项目只要继承了父项目，
    子项目以后写依赖就不需要版本号了，所有我们可以看到我的这个项目基础了父项目(版本号2.3.4)，
    之后我们之后引入其他依赖，我们都没有写版本号，-->
<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-parent</artifactId>
	<version>2.3.4.RELEASE</version>
</parent>

上面项目的父项目如下：
<parent>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-dependencies</artifactId>
	<version>2.3.4.RELEASE</version>
</parent>

<!--它几乎声明了所有开发中常用的依赖的版本号，自动版本仲裁机制
比如我们在数据库开发的时候，我们想要连接mysql的时候 直接在 <dependencies> 导入mysql驱动，不需要添加版本号-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
</dependency>
```



#### 2) Starters

Starters 是一组方便的依赖描述符，你可以将其包含在你的应用程序中。获得所需的所有 Spring 和相关技术的一站式商店，而无需搜索示例代码和复制粘贴加载的依赖描述符。

#### 3) 开发导入starter场景启动器

作用：启动器包含许多依赖项，你需要这些依赖项使项目快速启动并运行，并具有一致的、受支持的托管传递依赖项集。

```xml
1）Spring官方命名方式： spring-boot-starter-* ,   *就某种场

	例如，你想开始使用 web
	请将 spring-boot-starter-data-jpa 依赖项包含在您的项目中。

2）只要引入starter，这个场景的 所有常规 需要的依赖我们都自动引入了

3）第三方提供的简化开发的场景启动器,通常以项目名称开头 ：
    		*-spring-boot-
    		
4）所有场景启动器最底层的依赖 都是 spring-boot-starter
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter</artifactId>
	<version>2.3.4.RELEASE</version>
	<scope>compile</scope>
</dependency>

```

[更多SpringBoot所有支持的场景](https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter)



#### 4) 自动版本仲裁机制

​	① 无需关注版本号，自动版本仲裁

​	 	引入依赖默认都可以不写版本

​	 	引入非版本仲裁的jar，要写版本号。

```xml
<!-- 1）我们点进父项目的 <artifactId>spring-boot-starter-parent</artifactId> 查看其内容，部分内容如下：-->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-dependencies</artifactId>
    <version>2.3.4.RELEASE</version>
</parent>

<!-- 2）发现呢它还有一个父项目，我们继续点进去查看其内容，可以看到里面声明了我们开发过程中需要用到的所有常用
		jar包的版本号和依赖，也就是说我们在spring-boot-dependencies里面声明了很多jar包的版本号和依赖，所
		以我们无需写版本号，这就是自动版本仲裁机制。-->

<properties>
    <mysql.version>8.0.21</mysql.version>
    ...
</properties>
```

② 可以修改默认版本号

```xml
<!-- 如何不使用版本仲裁机制所提供的版本号-->
<!-- 比如我们不想使用默认提供的mysql驱动的版本号8.0.21，想用版本号为5.1.43的mysql，那我们应该怎么办呢？-->

两种解决方案：

1）在本项目中 使用<properties> ，修改版本号
    - 查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。
    - 在当前项目里面重写配置
    
    <properties>
        <mysql.version>5.1.43</mysql.version>
    </properties>

2）在导入依赖的时候直接加上需要修改的版本号
    
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>

这两种方法其实都是利用maven提供的特性，就近优先原则，就是在当前项目中已经配置了某个依赖的版本号我就使用其版
本号，如果当前项目中没有配置其版本号，我就去其父项目中找其版本号。
```



IDEA快捷键：

- ` ctrl + shift + alt + U`：以图的方式显示项目中依赖之间的关系。
- `alt + ins`：相当于Eclipse的 Ctrl + N，创建新类，新包等。



### 7. 自动配置特性



#### 1) 自动配好Tomcat

- 引入Tomcat依赖。
- 配置Tomcat

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-tomcat</artifactId>
	<version>2.3.4.RELEASE</version>
	<scope>compile</scope>
</dependency>
```



#### 2) 自动配好SpringMVC

- 引入SpringMVC全套组件
- 自动配好SpringMVC常用组件（功能）



#### 3) 自动配好Web常见功能

​	如：字符编码问题

​	SpringBoot帮我们配置好了所有web开发的常见场景

```java
public static void main(String[] args) {
    //1、返回我们IOC容器
    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

    //2、查看容器里面的组件
    String[] names = run.getBeanDefinitionNames();
    for (String name : names) {
        System.out.println(name);
    }
}
```



#### 4) 默认的包结构

```java
/*
主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来
- 无需以前的包扫描配置
- 想要改变扫描路径
	- @SpringBootApplication(scanBasePackages="com.lun")
	- @ComponentScan 指定扫描路径
*/
@SpringBootApplication
等同于
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan("com.lun")
```



#### 5) 各种配置拥有默认值

- 默认配置最终都是映射到某个类上，如：`MultipartProperties`
- 配置文件的值最终会绑定每个类上，这个类会在容器中创建对象



#### 6) 按需加载所有自动配置项

- 非常多的starter
- 引入了哪些场景这个场景的自动配置才会开启
- SpringBoot所有的自动配置功能都在 spring-boot-autoconfigure 包里面

	

## 二、底层注解



### 1. @Configuration



##### 1）@Configuration的三个特性

- 该注解的配置类里面使用@Bean标注在方法上给容器注册组件，默认也是单实例的。
- 被这个注解的配置类本身也是组件。
- 该注解的属性proxyBeanMethods 可以通过“true” 和 “false” 配置值，来控制使用的模式 



**演示一下前两个特性**

在SpringBoot中 可以编写一个 ==Config配置类==  使用 ==@Configuration== 

```java
/**
 * 1. 配置类里面使用 @Bean标注在方法上，给容器注册组件，默认单实例
 * 2. 配置类本身也是组件
 */
@Configuration //告诉SpringBoot这是一个配置类 == 配置文件 
public class MyConfig {

    //无论对配置类中的这个 组件注册方法 调用多少次默认获取的都是之前注册容器中的 单实例对象
    @Bean //给容器中添加中组件，以方法名作为组件id，返回类型就是组件类型，返回值就是组件在容器中的实例
    public User user01(){
        return new User("张三", 18);
    }

    @Bean("tom") //默认组件名为方法名，也可以这样修改
    public Pet tomcat(){
        return new Pet("tomcat");
    }
    
}
```

我们可以在主程序中获取这些组件

```java
//@SpringBootApplication：是SpringBoot的核心注解，目的是开启自动配置
//里面还有有好多注解，比如 自动扫描注解 @ComponentScan()
//我们可以修改 改变扫描路径 ：(scanBasePackages = "com.lhc")
@SpringBootApplication(scanBasePackages = "com.lhc")
public class MainApplication {
    public static void main(String[] args) {
  
        //1. 返回IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class,args);

        //2. 查看容器里面的组件
        String[] names = run.getBeanDefinitionNames();
        for (String name : names) {
            System.out.println(name);
        }

        //3. 从容器中获取组件

        Pet tom01 = run.getBean("tom", Pet.class);

        Pet tom02 = run.getBean("tom", Pet.class);

        System.out.println("使用@Bean给容器添加组件，默认也是单实例：" + (tom01 == tom02));

        //4. MyConfig配置类 本身也是组件,可以通过获取组件的方法获取
        MyConfig bean = run.getBean(MyConfig.class); 

    }

}
```



##### 2）proxyBeanMethods  属性

###### (1) 介绍

@Configuration 的属性 proxyBeanMethods 可以通过 "true" 和 "false" 配置值，来控制使用的模式 

- **Full 模式 Lite 模式**

	Full 模式 : proxyBeanMethods = true 或不写，

	Lite 模式 : proxyBeanMethods = false 是lite模式

- **Full模式下 调用注册组件方法 返回的都是 原来的Bean**

	外部无论对配置类中的组件注册方法调用多少次，获取的都是之前注册容器中的单实例对象。

- **Lite模式下 调用注册组件方法 返回的都是 新实例对象**

	在容器中不会保留代理对象，外部多次调用这些组件时，每次调用都会产生一个新的对象。

- **这两种模式的存在主要用于解决组件依赖场景**

	

###### (2) 案例演示



Config配置类 

```java
/*
1. 配置类本身也是组件
2. proxyBeanMethods 可以设置是不是 代理Bean的方法， 默认为 true
    1) Full (proxyBeanMethods = true)    
    2) Lite (proxyBeanMethods = false)
*/
@Configuration(proxyBeanMethods = false) 
public class MyConfig {

    @Bean 
    public User user01() {
        return new User("张三", 18);
    }

    @Bean("tom")
    public Pet tomcat() {
        return new Pet("tomcat");
    }
    
}
```

主程序 

```java
@SpringBootApplication(scanBasePackages = "com.lhc")
public class MainApplication {
    public static void main(String[] args) {

        // 返回IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class,args);
        
        //1. 查看 获取的  MyConfig组件 是不是一个代理对象
        //	1) 如果在配置类中 使用的是 (proxyBeanMethods = true) 则输出：
        //    	com.lhc.boot.config.MyConfig$$EnhancerBySpringCGLIB$$975aa5b0@56da7487
        //    	表示MyConfig 是一个代理对象
        //	2) 如果在配置类中 使用的是 (proxyBeanMethods = false) 则输出：
        //    	com.lhc.boot.config.MyConfig@6cff61fc
        //    	表示不是一个代理对象
        MyConfig bean = run.getBean(MyConfig.class); 
        System.out.println("输出bean查看 他是不是一个代理对象" + bean);

        //2. 在这里调用 配置类中的 @Bean标注的方法 即组件注册的方法
        //    是直接从容器中获取，还是 普通的方法调用创建新对象
        //    这个是取决于 配置类中 proxyBeanMethods 为 true/false ：
        //	1）如果为 true 表示 MyConfig 是一个代理对象，使用代理对象调用方法
        //    	SpringBoot就会去检查容器中有没有 这个方法返回的组件 如果有就直接获取, 即保持组件单实例
        //	2）如果为 false 表示MyConfig 不是一个代理对象 ,普通调用方法，创建新对象
        User user = bean.user01();
        User user1 = bean.user01();
        System.out.println("代理对象调用方法" + (user == user1));

    }

}
```



###### (3) 使用场景

​	组件依赖必须使用Full模式默认。其他默认是否Lite模式

 Config配置类 

```java
/*
proxyBeanMethods 可以设置是不是 代理Bean的方法，默认为是 (proxyBeanMethods = true)
    1) Full (proxyBeanMethods = true)
		
    2) Lite (proxyBeanMethods = false)

*/
@Configuration(proxyBeanMethods = true) 
public class MyConfig {

    @Bean 
    public User user01() {
        User zhangsan = new User("张三", 18);
        //组件依赖
        zhangsan.setPet(tomcat());
        return zhangsan;
    }

    @Bean("tom") 
    public Pet tomcat() {
        return new Pet("tomcat");
    }
}

```

主程序类

```java
@SpringBootApplication(scanBasePackages = "com.lhc")
public class MainApplication {
    public static void main(String[] args) {

        // 返回IOC容器
        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class,);       


        //分别获取 user01 组件 和 tom组件 
        User user01 = run.getBean("user01", User.class);
        Pet tom = run.getBean("tom", Pet.class);
        
       	//1) Full模式（proxyBeanMethods = true）时，输出true，
       	//   说明是从容器中获取的同一个组件（用户的宠物就是容器中的宠物）
        //2）Lite模式（proxyBeanMethods = false）时，输出false，
       	//   说明是从容器中获取的不是同一个组件（用户的宠物不是容器中的宠物， 相当于new 了另一个对象）
        System.out.println("用户的宠物是否为 调用方法的宠物" + (user01.getPet() == tom));

    }

}
```



###### (4) 最佳实战

- 配置 类组件之间**无依赖关系** 用Lite模式 

	理由：用Lite模式，Spring Boot 不检查容器中是否有没有相应的组件，而是直接new一个，**加速容器启动过程，减少判断**

- 配置 类组件之间**有依赖关系** 用Full模式（默认）

	理由：用Full模式，Spring Boot 每次都会检查容器中是否有相应的组件，**方法会被调用得到之前单实例组件**

---------------------------------------

> lite 英 [laɪt]   美 [laɪt]  
> adj. 低热量的，清淡的(light的一种拼写方法);类似…的劣质品

---

IDEA快捷键：

- `Alt + Ins`:生成getter，setter、构造器等代码。
- `Ctrl + Alt + B`:查看类的具体实现代码。

---------------------------------------



### 2. @Import导入组件

@Bean、@Component、@Controller、@Service、@Repository，它们是Spring的基本标签，在Spring Boot中并未改变它们原来的功能。

```java
@Import({User.class, DBHelper.class})    //给容器中自动创建出这两个类型的组件、默认组件的名字就是全类名
@Configuration(proxyBeanMethods = false) //告诉SpringBoot这是一个配置类 == 配置文件
public class MyConfig {
    
}
```

测试类：

```java

//1、返回我们IOC容器
ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

//7 从容器中获取组件 
//1) 获取所有 User类型的所有组件
String[] beanNamesForType = run.getBeanNamesForType(User.class);
for (String s : beanNamesForType){
    System.out.println(s);
}

//2) 获取 DBHelper类型的组件
DBHelper bean1 = run.getBean(DBHelper.class);
System.out.println(bean1);
// 3）输出结果：
// com.lhc.boot.bean.User                          这个是@Import() 导入的
// user01                                          这个是@Bean方法 导入的
// ch.qos.logback.core.db.DBHelper@bf71cec         这个是@Import() 导入的
//
// @Import() 导入的组件名字 默认为全类名

DBHelper bean1 = run.getBean(DBHelper.class);
System.out.println(bean1);
```





### 3. @Conditional条件装配

**条件装配：满足Conditional指定的条件，则进行组件注入**



@ Conditional 类的继承树

![在这里插入图片描述](image/20210205005453173.png)

@Conditional 的继承树可以看出，@Conditional 有非常多的派生注解，每个注解都代表不同的功能，从派生注解的注解名称可以大概知道其功能用意，比如：

```java
//1.class条件注解
@ConditionalOnClass：某个class位于类路径上，才会实例化一个Bean。
@ConditionalOnMissingClass：某个class类路径上不存在的时候，才会实例化一个Bean。

//2.Bean条件注解
@ConditionalOnBean：当容器中有指定Bean 才进行实例化。
@ConditionalOnMissingBean：当容器里没有指定Bean 才进行实例化。

//3.属性条件注解
@ConditionalOnProperty：当指定的属性有指定的值 才进行实例化。

//4.Resource条件注解
@ConditionalOnResource：当类路径下有指定的资源 才触发实例化。

//5.web条件注解
@ConditionalOnNotWebApplication：不是web应用，才会实例化一个Bean。
@ConditionalOnWebApplication：当项目是一个Web项目 才进行实例化。

//6.表达式条件注解
@ConditionalOnExpression：基于SpEL表达式的条件判断，当表达式为true的时候，才会实例化一个Bean。

@ConditionalOnJava：当JVM版本为指定的版本范围时触发实例化。
@ConditionalOnJndi：在JNDI存在的条件下触发实例化。
@ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个，或者有多个但是指定了首选的Bean时触发实例化。
```



用@ConditionalOnMissingBean举例说明

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean(name = "tom")//没有tom名字的Bean时，MyConfig类的Bean才能生效。
public class MyConfig {

    @Bean
    public User user01(){
        User zhangsan = new User("zhangsan", 18);
        zhangsan.setPet(tomcatPet());
        return zhangsan;
    }

    @Bean("tom22")
    public Pet tomcatPet(){
        return new Pet("tomcat");
    }
}

public static void main(String[] args) {
    //1、返回我们IOC容器
    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

    //2、查看容器里面的组件
    String[] names = run.getBeanDefinitionNames();
    for (String name : names) {
        System.out.println(name);
    }

    boolean tom = run.containsBean("tom");
    System.out.println("容器中Tom组件："+tom);//false

    boolean user01 = run.containsBean("user01");
    System.out.println("容器中user01组件："+user01);//true

    boolean tom22 = run.containsBean("tom22");
    System.out.println("容器中tom22组件："+tom22);//true

}
```



### 4. @ImportResource原生配置文件引入

比如，公司使用bean.xml文件生成配置bean，然而你为了省事，想继续复用bean.xml，@ImportResource粉墨登场。

bean.xml：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans ...">
    <bean id="haha" class="com.lun.boot.bean.User">
        <property name="name" value="zhangsan"></property>
        <property name="age" value="18"></property>
    </bean>

    <bean id="hehe" class="com.lun.boot.bean.Pet">
        <property name="name" value="tomcat"></property>
    </bean>
</beans>
```

使用方法：

```java
@ImportResource("classpath:beans.xml")
public class MyConfig {
...
}
```

测试类：

```java
public static void main(String[] args) {
    //1、返回我们IOC容器
    ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);

	boolean haha = run.containsBean("haha");
	boolean hehe = run.containsBean("hehe");
	System.out.println("haha："+haha);//true
	System.out.println("hehe："+hehe);//true
}
```



### 5. @ConfigurationProperties配置绑定

如何使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用

#### 1) 传统方法

```java
public class getProperties {
     public static void main(String[] args) throws FileNotFoundException, IOException {
         Properties pps = new Properties();
         pps.load(new FileInputStream("a.properties"));
         Enumeration enum1 = pps.propertyNames();//得到配置文件的名字
         while(enum1.hasMoreElements()) {
             String strKey = (String) enum1.nextElement();
             String strValue = pps.getProperty(strKey);
             System.out.println(strKey + "=" + strValue);
             //封装到JavaBean。
         }
     }
 }
```

---



#### 2) Spring Boot一种配置配置绑定

**@ConfigurationProperties + @Component**

假设 有配置文件application.properties

```properties
mycar.brand=BYD
mycar.price=100000
```

只有在容器中的组件，才会拥有SpringBoot提供的强大功能

```java
@Component	//表示将Car加入到容器中
@ConfigurationProperties(prefix = "mycar") //配置绑定
public class Car {
	...
}
```

---

#### 3) Spring Boot另一种配置配置绑定

**@EnableConfigurationProperties + @ConfigurationProperties**

1. 开启Car配置绑定功能
2. 把这个Car这个组件自动注册到容器中


```java
//1) 开启Car配置绑定功能
//2）把这个Car这个组件自动注册到容器中
@EnableConfigurationProperties(Car.class)	
public class MyConfig {
	...
}
```

```java
@ConfigurationProperties(prefix = "mycar") //配置绑定
public class Car {
	...
}
```



## 三、自动配置【源码分析】



==@SpringBootApplication==

```java
//Spring Boot应用的启动类
@SpringBootApplication
public class MainApplication {

    public static void main(String[] args) {
        SpringApplication.run(MainApplication.class, args);
    }

}
```

分析下 @SpringBootApplication

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters = {@Filter(
    type = FilterType.CUSTOM,
    classes = {TypeExcludeFilter.class}
), @Filter(
    type = FilterType.CUSTOM,
    classes = {AutoConfigurationExcludeFilter.class}
)}
)
public @interface SpringBootApplication {
    ...
}
```

**重点分析 @SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan。**



### 1. @SpringBootConfiguration

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration  //代表当前是一个配置类。
public @interface SpringBootConfiguration {
    @AliasFor(
        annotation = Configuration.class
    )
    boolean proxyBeanMethods() default true;
}
```



### 2. @ComponentScan

​	指定扫描哪些Spring注解。



### 3. @EnableAutoConfiguration

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

    Class<?>[] exclude() default {};

    String[] excludeName() default {};
}
```

重点分析 **@AutoConfigurationPackage，@Import(AutoConfigurationImportSelector.class)**



#### 1）@AutoConfigurationPackage

标签名直译为：**自动配置包，指定了默认的包规则。**

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(AutoConfigurationPackages.Registrar.class)//给容器中导入组件
public @interface AutoConfigurationPackage {
    String[] basePackages() default {};

    Class<?>[] basePackageClasses() default {};
}


//AutoConfigurationPackages.Registrar.class 代码--》
static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {
    Registrar() {
    }
	
	//获取指定包下的所有组件 （获取"com.atguigu.boot"下的所有组件）
    public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
        
        //(String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0]) --> "com.atguigu.boot"
        // 默认为主函数所在的包路径,也可以通过@ComponentScan改变该值
        AutoConfigurationPackages.register(
            registry, (String[])(new PackageImports(metadata)).getPackageNames().toArray(new String[0])
        );
    }

    public Set<Object> determineImports(AnnotationMetadata metadata) {
        return Collections.singleton(new PackageImports(metadata));
    }
}
```

- 利用Registrar给容器中导入一系列组件
- 将指定的一个包下的所有组件导入进MainApplication所在包下。



#### 2）@Import(AutoConfigurationImportSelector.class)

​	作用：**初始加载自动配置类**



AutoConfigurationImportSelector类

```java
 
//AutoConfigurationImportSelector.class 中的selectImports方法
public String[] selectImports(AnnotationMetadata annotationMetadata) {
    if (!this.isEnabled(annotationMetadata)) {
        return NO_IMPORTS;
    } else {
        //给容器中批量导入一些组件
        AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(annotationMetadata);
        return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
    }
}

//getAutoConfigurationEntry()
protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
    if (!this.isEnabled(annotationMetadata)) {
        return EMPTY_ENTRY;
    } else {
        AnnotationAttributes attributes = this.getAttributes(annotationMetadata);
        //获取到所有需要导入到容器中的配置类
        List<String> configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
        configurations = this.removeDuplicates(configurations);
        Set<String> exclusions = this.getExclusions(annotationMetadata, attributes);
        this.checkExcludedClasses(configurations, exclusions);
        configurations.removeAll(exclusions);
        configurations = this.getConfigurationClassFilter().filter(configurations);
        this.fireAutoConfigurationImportEvents(configurations, exclusions);
        return new AutoConfigurationEntry(configurations, exclusions);
    }
}

//getCandidateConfigurations()
protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());
    Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.");
    return configurations;
}


```

1）利用 getAutoConfigurationEntry(annotationMetadata); 给容器中批量导入一些组件
2）调用 List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes) 获取到所有需要导到容器中的配置类
3）利用工厂加载 Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader); 得到所有的组件
4）从META-INF/spring.factories位置来加载一个文件。
	默认扫描我们当前系统里面所有 META-INF/spring.factories 位置的文件
	spring-boot-autoconfigure-2.3.4.RELEASE.jar 包里面也有 META-INF/spring.factories

```properties
# 文件里面写死了spring-boot一启动就要给容器中加载的所有配置类
# spring-boot-autoconfigure-2.3.4.RELEASE.jar/META-INF/spring.factories
# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
...
```

虽然我们127个场景的所有自动配置启动的时候默认全部加载，但是`xxxxAutoConfiguration`按照**条件装配规则**（`@Conditional`），最终会按需配置。

如`AopAutoConfiguration`类：

```java
@Configuration(
    proxyBeanMethods = false
)
@ConditionalOnProperty(
    prefix = "spring.aop",
    name = "auto",
    havingValue = "true",
    matchIfMissing = true
)
public class AopAutoConfiguration {
    public AopAutoConfiguration() {
    }
	...
}
```



### 3. 自动配置流程



(1) SpringBoot默认会在底层配好所有的组件

​	以`DispatcherServletAutoConfiguration`的内部类`DispatcherServletConfiguration`为例子:

```java
@AutoConfigureOrder(Integer.MIN_VALUE)
@Configuration( roxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({DispatcherServlet.class})
@AutoConfigureAfter({ServletWebServerFactoryAutoConfiguration.class})
public class DispatcherServletAutoConfiguration {

    //声明这是一个配置类（ Lite模式 ）
    @Configuration( proxyBeanMethods = false )
    //当容器满足此条件 这个配置类才生效
    @Conditional({DefaultDispatcherServletCondition.class})
    //当类路径下有此class 这个配置类才生效
    @ConditionalOnClass({ServletRegistration.class})
    //开启 WebMvcProperties组件绑定功能，并且将WebMvcProperties组件注入到容器中
    @EnableConfigurationProperties({WebMvcProperties.class})
    protected static class DispatcherServletConfiguration {

        protected DispatcherServletConfiguration() {}

        //1、第一个bean: 向容器中注册 名为dispatcherServletf 的DispatcherServlet组件

        @Bean( name = {"dispatcherServlet"} )
        //给@Bean标注的方法传入了对象参数，这个参数的值就会从容器中找。（上面注解已经将其注入到容器中）
        //上面注解还给 WebMvcProperties组件绑定了一个properties配置文件，在配置文件中给 WebMvcProperties组件里属性赋值
        public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) {
            DispatcherServlet dispatcherServlet = new DispatcherServlet();
            dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());
            dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());
            dispatcherServlet.setThrowExceptionIfNoHandlerFound(webMvcProperties.isThrowExceptionIfNoHandlerFound());
            dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());
            dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails());
            return dispatcherServlet;
        }



        //2、第二个bean：向容器中注册 名为multipartResolver 的MultipartResolver组件

        //向容器中注册组件 
        @Bean
        //当容器中有这个类型组件 才生效
        @ConditionalOnBean({MultipartResolver.class})
        //容器中不存在 名为multipartResolver的组件 才生效 
        @ConditionalOnMissingBean( name = {"multipartResolver"})
        //传入一个 MultipartResolver对象参数 (这个参数会去容器中找)
        public MultipartResolver multipartResolver(MultipartResolver resolver) {
            //返回这个参数值（@Bean标注的方法 以方法返回值为组件 方法名为组件名）
            // 防止有些用户配置的文件上传解析器命名 不符合规范
            return resolver;
        }

    }
}
```



(2) 如果用户自己配置了以用户的优先

```java
//我们可以在配置类中自己重新配置一些组件
@Bean
@ConditionalOnMissingBean
public CharacterEncodingFilter characterEncodingFilter() {
    
}
```

SpringBoot默认会在底层配好所有的组件，但是**如果用户自己配置了以用户的优先**。



**总结**：

- SpringBoot先加载所有的自动配置类  xxxxxAutoConfiguration

- 每个自动配置类按照条件进行生效，默认都会绑定配置文件指定的值。

	（xxxxProperties里面读取，xxxProperties和配置文件进行了绑定）

- 生效的配置类就会给容器中装配很多组件

- 只要容器中有这些组件，相当于这些功能就有了

- 定制化配置
	- 用户直接自己@Bean替换底层的组件
	- 用户去看这个组件是获取的配置文件什么值就去修改。

**xxxxxAutoConfiguration ---> 组件 ---> xxxxProperties里面拿值  ----> application.properties**



## 四、最佳实践

### 1. SpringBoot应用如何编写

- 引入场景依赖
	- [官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter)
- 查看自动配置了哪些（选做）
	- 自己分析，引入场景对应的自动配置一般都生效了
	- 配置文件中debug=true开启自动配置报告。
	  - Negative（不生效）
	  - Positive（生效）
- 是否需要修改
	- 参照文档修改配置项
		- [官方文档](https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html#common-application-properties)
		- 自己分析。xxxxProperties绑定了配置文件的哪些。
	- 自定义加入或者替换组件
		- @Bean、@Component...
	- 自定义器  XXXXXCustomizer；
	- ......

### 2. Lombok简化开发

Lombok用标签方式代替构造器、getter/setter、toString()等鸡肋代码。

spring boot已经管理Lombok。引入依赖：

```xml
 <dependency>
     <groupId>org.projectlombok</groupId>
     <artifactId>lombok</artifactId>
</dependency>
```

IDEA中File->Settings->Plugins，搜索安装Lombok插件。

```java
@NoArgsConstructor
//@AllArgsConstructor
@Data
@ToString
@EqualsAndHashCode
public class User {

    private String name;
    private Integer age;

    private Pet pet;

    public User(String name,Integer age){
        this.name = name;
        this.age = age;
    }
}
```

---

简化日志开发

```java
@Slf4j
@RestController
public class HelloController {
    @RequestMapping("/hello")
    public String handle01(@RequestParam("name") String name){
        log.info("请求进来了....");
        return "Hello, Spring Boot 2!"+"你好："+name;
    }
}
```

### 3. dev-tools

> Spring Boot includes an additional set of tools that can make the application development experience a little more pleasant. The `spring-boot-devtools` module can be included in any project to provide additional development-time features.——[link](https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools)
>
> Applications that use `spring-boot-devtools` automatically restart whenever files on the classpath change. This can be a useful feature when working in an IDE, as it gives a very fast feedback loop for code changes. By default, any entry on the classpath that points to a directory is monitored for changes. Note that certain resources, such as static assets and view templates, [do not need to restart the application](https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools-restart-exclude).——[link](https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/html/using-spring-boot.html#using-boot-devtools-restart)
>
> Triggering a restart
>
> As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. The way in which you cause the classpath to be updated depends on the IDE that you are using:
>
> - In Eclipse, saving a modified file causes the classpath to be updated and triggers a restart.
> - In IntelliJ IDEA, building the project (`Build -> Build Project`)(shortcut: Ctrl+F9) has the same effect.

添加依赖：

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

在IDEA中，项目或者页面修改以后：Ctrl+F9。

### 4. Spring Initailizr
[Spring Initailizr](https://start.spring.io/)是创建Spring Boot工程向导。

在IDEA中，菜单栏New -> Project -> Spring Initailizr。



## 五、配置文件



### 1. yaml的用法

同以前的properties用法

YAML 是 "YAML Ain't Markup Language"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是："Yet Another Markup Language"（仍是一种标记语言）。 

**非常适合用来做以数据为中心的配置文件**。

#### 1) 基本语法

- key: value；kv之间有空格
- 大小写敏感
- 使用缩进表示层级关系
- 缩进不允许使用tab，只允许空格
- 缩进的空格数不重要，只要相同层级的元素左对齐即可
- '#'表示注释
- 字符串无需加引号，如果要加，单引号''、双引号""表示字符串内容会被 转义、不转义

#### 2) 数据类型

- 字面量：单个的、不可再分的值。date、boolean、string、number、null

```yaml
k: v
```

- 对象：键值对的集合。map、hash、set、object 

```yaml
#行内写法：  

k: {k1:v1,k2:v2,k3:v3}

#或

k: 
  k1: v1
  k2: v2
  k3: v3
```

- 数组：一组按次序排列的值。array、list、queue

```yaml
#行内写法：  

k: [v1,v2,v3]

#或者

k:
 - v1
 - v2
 - v3
```

#### 3) 实例

```java
@Data
public class Person {
    private String userName;
    private Boolean boss;
    private Date birth;
    private Integer age;
    private Pet pet;
    private String[] interests;
    private List<String> animal;
    private Map<String, Object> score;
    private Set<Double> salarys;
    private Map<String, List<Pet>> allPets;
}

@Data
public class Pet {
    private String name;
    private Double weight;
}
```

用yaml表示以上对象

```yaml
person:
  userName: zhangsan
  boss: false
  birth: 2019/12/12 20:12:33
  age: 18
  pet: 
    name: tomcat
    weight: 23.4
  interests: [篮球,游泳]
  animal: 
    - jerry
    - mario
  score:
    english: 
      first: 30
      second: 40
      third: 50
    math: [131,140,148]
    chinese: {first: 128,second: 136}
  salarys: [3999,4999.98,5999.99]
  allPets:
    sick:
      - {name: tom}
      - {name: jerry,weight: 47}
    health: [{name: mario,weight: 47}]
```





### 2. 自定义类绑定的配置提示

> You can easily generate your own configuration metadata file from items annotated with `@ConfigurationProperties` by using the `spring-boot-configuration-processor` jar. The jar includes a Java annotation processor which is invoked as your project is compiled.——[link](https://docs.spring.io/spring-boot/docs/2.4.2/reference/htmlsingle/#configuration-metadata-annotation-processor)

自定义的类和配置文件绑定一般没有提示。若要提示，添加如下依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
</dependency>

<!-- 下面插件作用是工程打包时，不将spring-boot-configuration-processor打进包内，让其只在编码的时候有用 -->
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
            <configuration>
                <excludes>
                    <exclude>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-configuration-processor</artifactId>
                    </exclude>
                </excludes>
            </configuration>
        </plugin>
    </plugins>
</build>
```

## 六、web场景

### 1. web开发简介

Spring Boot provides auto-configuration for Spring MVC that **works well with most applications.(大多场景我们都无需自定义配置)**

The auto-configuration adds the following features on top of Spring’s defaults:

- Inclusion of `ContentNegotiatingViewResolver` and `BeanNameViewResolver` beans.

  - 内容协商视图解析器和BeanName视图解析器

- Support for serving static resources, including support for WebJars (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-static-content))).

  - 静态资源（包括webjars）

- Automatic registration of `Converter`, `GenericConverter`, and `Formatter` beans.

  - 自动注册 `Converter，GenericConverter，Formatter `

- Support for `HttpMessageConverters` (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-message-converters)).

  - 支持 `HttpMessageConverters` （后来我们配合内容协商理解原理）

- Automatic registration of `MessageCodesResolver` (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-message-codes)).

  - 自动注册 `MessageCodesResolver` （国际化用）

- Static `index.html` support.

  - 静态index.html 页支持

- Custom `Favicon` support (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-favicon)).

  - 自定义 `Favicon`  

- Automatic use of a `ConfigurableWebBindingInitializer` bean (covered [later in this document](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-spring-mvc-web-binding-initializer)).

  - 自动使用 `ConfigurableWebBindingInitializer` ，（DataBinder负责将请求数据绑定到JavaBean上）

> If you want to keep those Spring Boot MVC customizations and make more [MVC customizations](https://docs.spring.io/spring/docs/5.2.9.RELEASE/spring-framework-reference/web.html#mvc) (interceptors, formatters, view controllers, and other features), you can add your own `@Configuration` class of type `WebMvcConfigurer` but **without** `@EnableWebMvc`.
>
> **不用@EnableWebMvc注解。使用** **`@Configuration`** **+** **`WebMvcConfigurer`** **自定义规则**

> If you want to provide custom instances of `RequestMappingHandlerMapping`, `RequestMappingHandlerAdapter`, or `ExceptionHandlerExceptionResolver`, and still keep the Spring Boot MVC customizations, you can declare a bean of type `WebMvcRegistrations` and use it to provide custom instances of those components.
>
> **声明** **`WebMvcRegistrations`** **改变默认底层组件**

> If you want to take complete control of Spring MVC, you can add your own `@Configuration` annotated with `@EnableWebMvc`, or alternatively add your own `@Configuration`-annotated `DelegatingWebMvcConfiguration` as described in the Javadoc of `@EnableWebMvc`.
>
> **使用** **`@EnableWebMvc+@Configuration+DelegatingWebMvcConfiguration 全面接管SpringMVC`**

### 2. 静态资源规则与定制化

#### 1) 静态资源目录

只要静态资源放在类路径下： called `/static` (or `/public` or `/resources` or `/META-INF/resources`

访问 ： 当前项目根路径/ + 静态资源名 

原理： 静态映射/**。

请求进来，先去找Controller看能不能处理。不能处理的所有请求又都交给静态资源处理器。静态资源也找不到则响应404页面。

也可以改变默认的静态资源路径，`/static`，`/public`,`/resources`, `/META-INF/resources`失效

```yaml
resources:
  static-locations: [classpath:/haha/]
```

#### 2) 静态资源访问前缀

```yaml
spring:
  mvc:
    static-path-pattern: /res/**
```

当前项目 + static-path-pattern + 静态资源名 = 静态资源文件夹下找

#### 3) webjar

可用jar方式添加css，js等资源文件，

[https://www.webjars.org/](https://www.webjars.org/)

例如，添加jquery

```xml
<dependency>
    <groupId>org.webjars</groupId>
    <artifactId>jquery</artifactId>
    <version>3.5.1</version>
</dependency>
```

访问地址：[http://localhost:8080/webjars/**jquery/3.5.1/jquery.js**](http://localhost:8080/webjars/jquery/3.5.1/jquery.js)  后面地址要按照依赖里面的包路径。



### 3. welcome与favicon功能

[官方文档](https://docs.spring.io/spring-boot/docs/2.3.8.RELEASE/reference/htmlsingle/#boot-features-spring-mvc-welcome-page)

#### 1) 欢迎页支持

- 静态资源路径下  index.html。

  - 可以配置静态资源路径
  - 但是不可以配置静态资源的访问前缀。否则导致 index.html不能被默认访问

```yaml
spring:
#  mvc:
#    static-path-pattern: /res/**   这个会导致welcome page功能失效
  resources:
    static-locations: [classpath:/haha/]
```

- controller能处理/index。

#### 2) 自定义Favicon

指网页标签上的小图标。

favicon.ico 放在静态资源目录下即可。

```yaml
spring:
#  mvc:
#    static-path-pattern: /res/**   这个会导致 Favicon 功能失效
```

### 4.静态资源原理【源码分析】

- SpringBoot启动默认加载  xxxAutoConfiguration 类（自动配置类）
- SpringMVC功能的自动配置类`WebMvcAutoConfiguration`，生效

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
		ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {
    ...
}
```

- 给容器中配置的内容：
  - 配置文件的相关属性的绑定：WebMvcProperties **spring.mvc**、ResourceProperties **spring.resources**

```java
@Configuration(proxyBeanMethods = false)
@Import(EnableWebMvcConfiguration.class)
@EnableConfigurationProperties({ WebMvcProperties.class, ResourceProperties.class })
@Order(0)
public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer {
    ...
}
```

#### 1) 配置类只有一个有参构造器

```java
////有参构造器所有参数的值都会从容器中确定
public WebMvcAutoConfigurationAdapter(WebProperties webProperties, WebMvcProperties mvcProperties,
		ListableBeanFactory beanFactory, ObjectProvider<HttpMessageConverters> messageConvertersProvider,
		ObjectProvider<ResourceHandlerRegistrationCustomizer> resourceHandlerRegistrationCustomizerProvider,
		ObjectProvider<DispatcherServletPath> dispatcherServletPath,
		ObjectProvider<ServletRegistrationBean<?>> servletRegistrations) {
	this.mvcProperties = mvcProperties;
	this.beanFactory = beanFactory;
	this.messageConvertersProvider = messageConvertersProvider;
	this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();
	this.dispatcherServletPath = dispatcherServletPath;
	this.servletRegistrations = servletRegistrations;
	this.mvcProperties.checkConfiguration();
}
```

- ResourceProperties resourceProperties；获取和spring.resources绑定的所有的值的对象
- WebMvcProperties mvcProperties 获取和spring.mvc绑定的所有的值的对象
- ListableBeanFactory beanFactory Spring的beanFactory
- HttpMessageConverters 找到所有的HttpMessageConverters
- ResourceHandlerRegistrationCustomizer 找到 资源处理器的自定义器。
- DispatcherServletPath
- ServletRegistrationBean   给应用注册Servlet、Filter....

#### 2) 资源处理的默认规则

```java
...
public class WebMvcAutoConfiguration {
    ...
	public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware {
        ...
		@Override
		protected void addResourceHandlers(ResourceHandlerRegistry registry) {
			super.addResourceHandlers(registry);
			if (!this.resourceProperties.isAddMappings()) {
				logger.debug("Default resource handling disabled");
				return;
			}
			ServletContext servletContext = getServletContext();
			addResourceHandler(registry, "/webjars/**", "classpath:/META-INF/resources/webjars/");
			addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -> {
				registration.addResourceLocations(this.resourceProperties.getStaticLocations());
				if (servletContext != null) {
					registration.addResourceLocations(new ServletContextResource(servletContext, SERVLET_LOCATION));
				}
			});
		}
        ...
        
    }
    ...
}
```

根据上述代码，我们可以同过配置禁止所有静态资源规则。

```yaml
spring:
  resources:
    add-mappings: false   #禁用所有静态资源规则
```

静态资源规则：

```java
@ConfigurationProperties(prefix = "spring.resources", ignoreUnknownFields = false)
public class ResourceProperties {

    private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { "classpath:/META-INF/resources/",
            "classpath:/resources/", "classpath:/static/", "classpath:/public/" };

    /**
     * Locations of static resources. Defaults to classpath:[/META-INF/resources/,
     * /resources/, /static/, /public/].
     */
    private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;
    ...
}

```

#### 3) 欢迎页的处理规则

```java
...
public class WebMvcAutoConfiguration {
    ...
	public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware {
        ...
		@Bean
		public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,
				FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) {
			WelcomePageHandlerMapping welcomePageHandlerMapping = new WelcomePageHandlerMapping(
					new TemplateAvailabilityProviders(applicationContext), applicationContext, getWelcomePage(),
					this.mvcProperties.getStaticPathPattern());
			welcomePageHandlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));
			welcomePageHandlerMapping.setCorsConfigurations(getCorsConfigurations());
			return welcomePageHandlerMapping;
		}
    
```

`WelcomePageHandlerMapping`的构造方法如下：

```java
WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,
                          ApplicationContext applicationContext, Resource welcomePage, String staticPathPattern) {
    if (welcomePage != null && "/**".equals(staticPathPattern)) {
        //要用欢迎页功能，必须是/**
        logger.info("Adding welcome page: " + welcomePage);
        setRootViewName("forward:index.html");
    }
    else if (welcomeTemplateExists(templateAvailabilityProviders, applicationContext)) {
        //调用Controller /index
        logger.info("Adding welcome page template: index");
        setRootViewName("index");
    }
}
```

这构造方法内的代码也解释了[web场景-welcome与favicon功能](#)中配置`static-path-pattern`了，welcome页面和小图标失效的问题。



## 七、请求处理



### 1. Rest映射及源码解析

#### 1) 请求映射



(1) @xxxMapping;
- @GetMapping

- @PostMapping

- @PutMapping

- @DeleteMapping

	

(2) Rest风格支持（使用**HTTP**请求方式动词来表示对资源的操作）

  以前：
- /getUser 获取用户
- /deleteUser 删除用户
- /editUser 修改用户
- /saveUser保存用户

  现在： /user 

- GET-获取用户
- DELETE-删除用户
- PUT-修改用户
- POST-保存用户

- 核心Filter；HiddenHttpMethodFilter



#### 2) 案例演示



(1) 开启页面表单的Rest功能

```yaml
spring:
  mvc:
    hiddenmethod:
      filter:
        enabled: true   #开启页面表单的Rest功能
```

(2) 页面 form 的属性 method=post ，隐藏域 \\_method=put、delete等（如果直接get或post，无需隐藏域）

```html
<form action="/user" method="get">
    <input value="REST-GET提交" type="submit" />
</form>

<form action="/user" method="post">
    <input value="REST-POST提交" type="submit" />
</form>

<form action="/user" method="post">
    <input name="_method" type="hidden" value="DELETE"/>
    <input value="REST-DELETE 提交" type="submit"/>
</form>

<form action="/user" method="post">
    <input name="_method" type="hidden" value="PUT" />
    <input value="REST-PUT提交"type="submit" />
<form>
```

(3) 编写请求映射

```java
@GetMapping("/user")
//@RequestMapping(value = "/user",method = RequestMethod.GET)
public String getUser(){
    return "GET-张三";
}

@PostMapping("/user")
//@RequestMapping(value = "/user",method = RequestMethod.POST)
public String saveUser(){
    return "POST-张三";
}

@PutMapping("/user")
//@RequestMapping(value = "/user",method = RequestMethod.PUT)
public String putUser(){
    return "PUT-张三";
}

@DeleteMapping("/user")
//@RequestMapping(value = "/user",method = RequestMethod.DELETE)
public String deleteUser(){
    return "DELETE-张三";
}
```



#### 3) Rest原理



(1) 表单提交会带上 \\_method=PUT

(2) **请求过来被** HiddenHttpMethodFilter 拦截

​    请求是否正常，并且是POST

​	① 获取到 \\_method 的值。

​	② 兼容以下请求: **PUT、DELETE、PATCH**

​	③ **原生request（post），包装模式requesWrapper重写了getMethod方法，返回的是传入的值。**

​	④ **过滤器链放行的时候用wrapper。以后的方法调用getMethod是调用requesWrapper的。**

```java
public class HiddenHttpMethodFilter extends OncePerRequestFilter {

	private static final List<String> ALLOWED_METHODS =
			Collections.unmodifiableList(Arrays.asList(HttpMethod.PUT.name(),
					HttpMethod.DELETE.name(), HttpMethod.PATCH.name()));

	/** Default method parameter: {@code _method}. */
	public static final String DEFAULT_METHOD_PARAM = "_method";

	private String methodParam = DEFAULT_METHOD_PARAM;


	/**
	 * Set the parameter name to look for HTTP methods.
	 * @see #DEFAULT_METHOD_PARAM
	 */
	public void setMethodParam(String methodParam) {
		Assert.hasText(methodParam, "'methodParam' must not be empty");
		this.methodParam = methodParam;
	}

	@Override
	protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {

		HttpServletRequest requestToUse = request;
		
        //判断请求是否为POST，并且没有什么异常
		if ("POST".equals(request.getMethod()) && request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == null) {
			//获取 _method 的值
            String paramValue = request.getParameter(this.methodParam);
			if (StringUtils.hasLength(paramValue)) {
                //将 _method的值转为大写
				String method = paramValue.toUpperCase(Locale.ENGLISH);
				if (ALLOWED_METHODS.contains(method)) { //判断 ALLOWED_METHODS 中是否包含了该值
                    //创建一个新的 requestToUse
					requestToUse = new HttpMethodRequestWrapper(request, method);
				}
			}
		}

       	//过滤器放行，放行的是新的 HttpServletRequest，
		filterChain.doFilter(requestToUse, response);
	}


	/**
	 * Simple {@link HttpServletRequest} wrapper that returns the supplied method for
	 * {@link HttpServletRequest#getMethod()}.
	 */
	private static class HttpMethodRequestWrapper extends HttpServletRequestWrapper {

		private final String method;

        
		public HttpMethodRequestWrapper(HttpServletRequest request, String method) {
			super(request);
			this.method = method;
		}

        //重写getMethod方法，返回传入的值，即_method的值
		@Override
		public String getMethod() {
			return this.method;
		}
	}

}
```

Rest使用客户端工具。

- 如PostMan可直接发送put、delete等方式请求。

### 2. 怎么改变默认的\_method

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
		ValidationAutoConfiguration.class })
public class WebMvcAutoConfiguration {

    ...
    
    @Bean
    @ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
    @ConditionalOnProperty(prefix = "spring.mvc.hiddenmethod.filter", name = "enabled", matchIfMissing = false)
    public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
        return new OrderedHiddenHttpMethodFilter();
    }
    
    ...
}
    
```

`@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)`意味着在没有`HiddenHttpMethodFilter`时，才执行`hiddenHttpMethodFilter()`。因此，我们可以自定义filter，改变默认的`\_method`。例如：

```java
@Configuration(proxyBeanMethods = false)
public class WebConfig{
    //自定义filter
    @Bean
    public HiddenHttpMethodFilter hiddenHttpMethodFilter(){
        HiddenHttpMethodFilter methodFilter = new HiddenHttpMethodFilter();
        methodFilter.setMethodParam("_m");
        return methodFilter;
    }    
}
```

将`\_method`改成`_m`。

```html
<form action="/user" method="post">
    <input name="_m" type="hidden" value="DELETE"/>
    <input value="REST-DELETE 提交" type="submit"/>
</form>
```



### 3. 常用参数注解使用

注解：

- `@PathVariable` 路径变量
- `@RequestHeader` 获取请求头
- `@RequestParam` 获取请求参数（指问号后的参数，url?a=1&b=2）
- `@CookieValue` 获取Cookie值
- `@RequestAttribute` 获取request域属性
- `@RequestBody` 获取请求体[POST]
- `@MatrixVariable` 矩阵变量
- `@ModelAttribute`

使用用例：

#### 1) @PathVariable

前端代码

```html
<a href="car/3/owner/lishi">测试@PathVariable</a>
```

后端代码

```java
@RestController
public class ParameterTestController {
    //car/2/owner/zhangsan
    @GetMapping("/car/{id}/owner/{username}")
    public Map<String,Object> getCar(@PathVariable("id") Integer id,
                                     @PathVariable("username") String name,
                                     @PathVariable Map<String,String> pv,
                                     @RequestHeader("User-Agent") String userAgent,
                                     @RequestHeader Map<String,String> header,
                                    ){

        Map<String,Object> map = new HashMap<>();
        map.put("id",id);
        map.put("name",name);
        map.put("pv",pv);
        return map;
    }

}
```

页面显示：

```json
{
   	"pv":{"id":"3","username":"lishi"},
    "name":"lishi",
    "id":"3"
}
```



#### 2) @RequestParam

前端代码

```html
<a href="car/3/owner/lishi?age=18&inters=basketball&inters=game">测试@RequestParam</a>
```

后端代码

```java
@RestController
public class ParameterTestController {

    @GetMapping("/car/{id}/owner/{username}")
    public Map<String,Object> getCar(@RequestParam("age") Integer age,
                                     @RequestParam("inters") List<String> inters, 
                                     @RequestParam Map<String,String> params, //获取所以params请求参数
    							 ){

        Map<String,Object> map = new HashMap<>();
        map.put("age",age);
        map.put("inters",inters);
        map.put("params",params);
        return map;
    }
}    
```

页面显示

```json
{
	"inters":["basketball","game"],
	"params":{"age":"18","inters":"basketball"},
	"age":18
}
```



#### 3) @RequestBody

前端代码

```html
<form action="/save" method="post">
	测试@RequestBody获取数据<br/>
    用户名：<input name="username"/> <br/>
    邮箱：<input name="email"/>
    <input type="submit" value="提交"/>
</form>
```

后端代码

```java
@RestController
public class ParameterTestController {

    @PostMapping("/save")
    public Map<String,Object> save(@RequestBody String content){

        Map<String,Object> map = new HashMap<>();
        map.put("content",content);
        return map;
    }				
```



#### 4) @RequestHeader 、@CookieValue

```java
@RestController
public class ParameterTestController {
    //car/2/owner/zhangsan
    @GetMapping("/car/{id}/owner/{username}")
    public Map<String,Object> getCar(@RequestHeader("User-Agent") String userAgent,
                                     @RequestHeader Map<String,String> header,
                                     @CookieValue("_ga") String ga,
                                     @CookieValue("_ga") Cookie cookie
                                    ){

        Map<String,Object> map = new HashMap<>();
        map.put("userAgent",userAgent);
        map.put("header",header);
         map.put("ga",ga);
        System.out.println(cookie.getName() +"===>" + cookie.getValue()); 
        return map;
    }

}
```





#### 5) @RequestAttribute

用例：

```java
@Controller
public class RequestController {

    @GetMapping("/goto")
    public String goToPage(HttpServletRequest request){
        
        request.setAttribute("msg","成功了...");
        request.setAttribute("code",200);
        return "forward:/success";  //转发到  /success请求
    }

    @GetMapping("/params")
    public String testParam(Map<String,Object> map,
                            Model model,
                            HttpServletRequest request,
                            HttpServletResponse response){
        map.put("hello","world666");
        model.addAttribute("world","hello666");
        request.setAttribute("message","HelloWorld");

        Cookie cookie = new Cookie("c1","v1");
        response.addCookie(cookie);
        return "forward:/success";
    }

    ///<-----------------主角@RequestAttribute在这个方法
    @ResponseBody
    @GetMapping("/success")
    public Map success(@RequestAttribute(value = "msg",required = false) String msg,
                       @RequestAttribute(value = "code",required = false)Integer code,
                       HttpServletRequest request){
        
        Object msg1 = request.getAttribute("msg");

        Map<String,Object> map = new HashMap<>();
        Object hello = request.getAttribute("hello");
        Object world = request.getAttribute("world");
        Object message = request.getAttribute("message");

        map.put("reqMethod_msg",msg1); //这个是直接到 @RequestAttribute注解中 取出保存到Attribute中的数据
        map.put("annotation_msg",msg); //这是使用 request 获取Attribute中保存的数据
        
        map.put("hello",hello);
        map.put("world",world);
        map.put("message",message);

        return map;
    }
}
```



#### 6) @MatrixVariable、UrlPathHelper

1. 语法： 请求路径：`/cars/sell;low=34;brand=byd,audi,yd`

2. SpringBoot默认是禁用了矩阵变量的功能
   

手动开启：原理。对于路径的处理。UrlPathHelper的removeSemicolonContent设置为false，让其支持矩阵变量的。

3. 矩阵变量**必须**有url路径变量才能被解析



**手动开启矩阵变量**：

- 实现`WebMvcConfigurer`接口：

```java
@Configuration(proxyBeanMethods = false)
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void configurePathMatch(PathMatchConfigurer configurer) {
        UrlPathHelper urlPathHelper = new UrlPathHelper();
        // 不移除；后面的内容。矩阵变量功能就可以生效
        urlPathHelper.setRemoveSemicolonContent(false);
        configurer.setUrlPathHelper(urlPathHelper);
    }
}
```

- 创建返回`WebMvcConfigurer`Bean：

```java
@Configuration(proxyBeanMethods = false)
public class WebConfig{
    @Bean
    public WebMvcConfigurer webMvcConfigurer(){
        return new WebMvcConfigurer() {
                        @Override
            public void configurePathMatch(PathMatchConfigurer configurer) {
                UrlPathHelper urlPathHelper = new UrlPathHelper();
                // 不移除；后面的内容。矩阵变量功能就可以生效
                urlPathHelper.setRemoveSemicolonContent(false);
                configurer.setUrlPathHelper(urlPathHelper);
            }
        }
    }
}
```



**`@MatrixVariable`的用例**

```java
@RestController
public class ParameterTestController {

    ///cars/sell;low=34;brand=byd,audi,yd
    @GetMapping("/cars/{path}")
    public Map carsSell(@MatrixVariable("low") Integer low,
                        @MatrixVariable("brand") List<String> brand,
                        @PathVariable("path") String path){
        Map<String,Object> map = new HashMap<>();

        map.put("low",low);
        map.put("brand",brand);
        map.put("path",path);
        return map;
    }

    // /boss/1;age=20/2;age=10

    @GetMapping("/boss/{bossId}/{empId}")
    public Map boss(@MatrixVariable(value = "age",pathVar = "bossId") Integer bossAge,
                    @MatrixVariable(value = "age",pathVar = "empId") Integer empAge){
        Map<String,Object> map = new HashMap<>();

        map.put("bossAge",bossAge);
        map.put("empAge",empAge);
        return map;

    }

}
```



## 八、请求处理-【源码分析】



==本章节对应的代码在 boot-05-web-01==



### 1. 请求映射原理(全过程)



![在这里插入图片描述](E:/SpringBoot%E7%AC%94%E8%AE%B0/image/20210205005703527.png)
**SpringMVC功能分析都从  org.springframework.web.servlet.DispatcherServlet -> doDispatch()**



案例演示：

```java
@GetMapping("/car/{id}/owner/{username}")
public Map<String,Object> getCar(@PathVariable("id") Integer id,
                                 @PathVariable("username") String name){
    
    Map<String,Object> map = new HashMap<>();
    map.put("id",id);
    map.put("name",name);
    return map;
}
```



网页调用 http://localhost:8888/car/1/owner/zhangsan，进入DispatcherServlet 的doDispatch()

**doDispatch() :**

```java
===================================================DispatcherServlet==========================================================

protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;
    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        try {
            ModelAndView mv = null;
            Exception dispatchException = null;

            try {
                processedRequest = this.checkMultipart(request);
                multipartRequestParsed = processedRequest != request;
                
                //1) 找到当前请求使用哪个Handler（Controller的方法）处理
                mappedHandler = this.getHandler(processedRequest);
                if (mappedHandler == null) {
                    this.noHandlerFound(processedRequest, response);
                    return;
                }

                //2) 为当前Handler 找一个适配器HandlerAdapter
                HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());
                String method = request.getMethod();
                boolean isGet = "GET".equals(method);
                if (isGet || "HEAD".equals(method)) {
                    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                    if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {
                        return;
                    }
                }

                if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                    return;
                }

                //3) 使用HandlerAdapter，执行目标方法
                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
                if (asyncManager.isConcurrentHandlingStarted()) {
                    return;
                }

                this.applyDefaultViewName(processedRequest, mv);
                mappedHandler.applyPostHandle(processedRequest, response, mv);
            } catch (Exception var20) {
                dispatchException = var20;
            } catch (Throwable var21) {
                dispatchException = new NestedServletException("Handler dispatch failed", var21);
            }

            this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);
        } catch (Exception var22) {
            this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);
        } catch (Throwable var23) {
            this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", var23));
        }

    } finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
            if (mappedHandler != null) {
                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            }
        } else if (multipartRequestParsed) {
            this.cleanupMultipart(processedRequest);
        }

    }
}
```



#### 1) getHandler() 

```java
@Nullable
protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {
    if (this.handlerMappings != null) {
        //循环遍历所有handlerMapping，找到这个请求对应的handler
        for (HandlerMapping mapping : this.handlerMappings) {
            HandlerExecutionChain handler = mapping.getHandler(request);
            if (handler != null) {
                return handler;
            }
        }
    }
    return null;
}
```

**this.handlerMappings 在Debug模式下展现的内容：**

![在这里插入图片描述](E:/SpringBoot%E7%AC%94%E8%AE%B0/image/20210205005802305.png)
其中，**RequestMappingHandlerMapping 中 保存了所有 @RequestMapping 和 handler 的映射规则**。

![在这里插入图片描述](E:/SpringBoot%E7%AC%94%E8%AE%B0/image/20210205005926474.png)

**所有的请求映射都在HandlerMapping中：**

- SpringBoot自动配置欢迎页的 WelcomePageHandlerMapping 。访问 /能访问到index.html；
- SpringBoot自动配置了默认 的 RequestMappingHandlerMapping

	请求进来，挨个尝试所有的HandlerMapping看是否有请求信息。
	- 如果有就找到这个请求对应的handler
	- 如果没有就是下一个 HandlerMapping
- 如果我们需要一些自定义的映射处理，我们也可以自己给容器中放**HandlerMapping**。自定义 **HandlerMapping**



#### 2) this.getHandlerAdapter()

```java
protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {
    if (this.handlerAdapters != null) {
        Iterator var2 = this.handlerAdapters.iterator();

        //查找一个适合这个handler的HandlerAdapter
        while(var2.hasNext()) {
            HandlerAdapter adapter = (HandlerAdapter)var2.next();
            //判断这个HandlerAdapter，是否支持这个handler
            if (adapter.supports(handler)) {
                return adapter;
            }
        }
    }

    throw new ServletException("No adapter for handler [" + handler + "]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler");
}
```

**this.handlerAdapters 在Debug模式下展现的内容：**

![1670240856035](E:\SpringBoot笔记\image\1670240856035.png)

0. 支持方法上标注 @RequestMapping
1. 支持函数式编程的
2. ...
3. ...



#### 3)  ha.handle()

```java
==================================== RequestMappingHandlerAdapter处理器适配器 ====================================

//进入RequestMappingHandlerAdapter的 handleInternal()
protected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
    this.checkRequest(request);
    ModelAndView mav;
    if (this.synchronizeOnSession) {
        HttpSession session = request.getSession(false);
        if (session != null) {
            Object mutex = WebUtils.getSessionMutex(session);
            synchronized(mutex) {
                mav = this.invokeHandlerMethod(request, response, handlerMethod);
            }
        } else {
            mav = this.invokeHandlerMethod(request, response, handlerMethod);
        }
    } else {
        //执行目标方法
        mav = this.invokeHandlerMethod(request, response, handlerMethod);
    }

    if (!response.containsHeader("Cache-Control")) {
        if (this.getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {
            this.applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);
        } else {
            this.prepareResponse(response);
        }
    }

    return mav;
}

//this.invokeHandlerMethod()
@Nullable
protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
                                           HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

    ServletWebRequest webRequest = new ServletWebRequest(request, response);
    try {
        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);
        
		//invocableMethod 目标方法类
        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
        
        // argumentResolvers 参数解析器
        if (this.argumentResolvers != null) {
            //获取所有的参数解析器，设置到invocableMethod中
            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        }
        
		// returnValueHandlers 返回值处理器
        if (this.returnValueHandlers != null) {
            //获取所有的返回值处理器，设置到invocableMethod中
            invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
        }
        
        ...
        
        //(1) 真正执行目标方法
        invocableMethod.invokeAndHandle(webRequest, mavContainer, new Object[0]);
        
        ...
    }
}         
```

##### 执行目标方法:

```java
============================================ ServletInvocableHandlerMethod ========================================

public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
    //执行目标方法
    Object returnValue = this.invokeForRequest(webRequest, mavContainer, providedArgs);
    
    
    this.setResponseStatus(webRequest);
    ...
}


//this.invokeForRequest() 执行目标方法
@Nullable
public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
    //(1) 获取目标方法每一个参数的值
    Object[] args = this.getMethodArgumentValues(request, mavContainer, providedArgs);
    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Arguments: " + Arrays.toString(args));
    }

    //(2) 通过反射调用目标方法
    return this.doInvoke(args);
}
```

##### (1) 获取目标方法参数值

```java
============================================= InvocableHandlerMethod ===============================================
//(1) this.getMethodArgumentValues()
protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
   	//获取方法上 所有参数的详细信息（如：参数标记的注解，参数的索引位置，参数的类型）
    MethodParameter[] parameters = this.getMethodParameters();
    //判断参数列表是否为空
    if (ObjectUtils.isEmpty(parameters)) {
        return EMPTY_ARGS;
    } else {
        Object[] args = new Object[parameters.length];
		//遍历参数列表
        for(int i = 0; i < parameters.length; ++i) {
            MethodParameter parameter = parameters[i];
            parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
            args[i] = findProvidedArgument(parameter, providedArgs);
            if (args[i] == null) {
                //(1.1) 判断 之前设置的26种参数解析器 是否存在一种参数解析器 支持解析该参数
                if (!this.resolvers.supportsParameter(parameter)) {
                    throw new IllegalStateException(formatArgumentError(parameter, "No suitable resolver"));
                }

                try {
                    //(1.2) 支持的话就开始解析吧
                    args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
                } catch (Exception var10) {
                    if (this.logger.isDebugEnabled()) {
                        String exMsg = var10.getMessage();
                        if (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {
                            this.logger.debug(formatArgumentError(parameter, exMsg));
                        }
                    }

                    throw var10;
                }
            }
        }

        return args;
    }
}
```

###### (1.1) 判断参数解析器

```java
========================================= HandlerMethodArgumentResolverComposite ===================================================

//(1.1) this.resolvers.supportsParameter(parameter) -->
@Nullable
private HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {
    HandlerMethodArgumentResolver result = (HandlerMethodArgumentResolver)this.argumentResolverCache.get(parameter);
    if (result == null) {
        Iterator var3 = this.argumentResolvers.iterator();

        //遍历所有的参数解析器
        while(var3.hasNext()) {
            HandlerMethodArgumentResolver resolver = (HandlerMethodArgumentResolver)var3.next();
            //(a) 判断是否支持解析 这个参数
            if (resolver.supportsParameter(parameter)) {
                result = resolver;
                //将参数信息,及支持的参数解析器 放入缓存中
                this.argumentResolverCache.put(parameter, resolver);
                break;
            }
        }
    }

    return result;
}


//每个参数解析器的 supportsParameter() 内部判断是否支持解析这个参数的原理不同
//下面是本例题中的 PathVariableMethodArgumentResolver参数解析器 判断原理
===================================== PathVariableMethodArgumentResolver参数解析器 =================================


```



###### (1.2) 开始解析

```java
//(1.2) this.resolvers.resolveArgument() -->
@Nullable
public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
    //获取缓存中的 参数解析器
    HandlerMethodArgumentResolver resolver = this.getArgumentResolver(parameter);
    if (resolver == null) {
        throw new IllegalArgumentException("Unsupported parameter type [" + parameter.getParameterType().getName() + "]. supportsParameter should be called first.");
    } else {
        //(1.2.1)调用 参数解析器的 resolveArgument() 进行参数解析
        return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
    }
}


//每个参数解析器的 resolveArgument() 内部解析原理不同
//下面是本例题中的 PathVariableMethodArgumentResolver参数解析器 解析原理
===================================== PathVariableMethodArgumentResolver参数解析器 ======================================================

//(1.2.1)调用参数解析器的 resolveArgument()
@Nullable
public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
    NamedValueInfo namedValueInfo = this.getNamedValueInfo(parameter);
    MethodParameter nestedParameter = parameter.nestedIfOptional();
    //获取需要解析的参数名
    Object resolvedName = this.resolveStringValue(namedValueInfo.name);
    if (resolvedName == null) {
        throw new IllegalArgumentException("Specified name must not resolve to null: [" + namedValueInfo.name + "]");
    } 
    //解析参数名对应的参数值 ：
    //以请求地址为/car/1/owner/zhangsan为例，请求进来时会将所有的路径变量存储到请求域中，直接从请求域获取参数值
    Object arg = this.resolveName(resolvedName.toString(), nestedParameter, webRequest);
        
    ...

}
```



##### (2) 通过反射调用目标方法

return this.doInvoke(args)； 【这里我们不讲解这一部分】



------

IDEA快捷键：

- Ctrl + Alt + U : 以UML的类图展现类有哪些继承类，派生类以及实现哪些接口。
- Crtl + Alt + Shift + U : 同上，区别在于上条快捷键结果在新页展现，而本条快捷键结果在弹窗展现。
- Ctrl + H : 以树形方式展现类层次结构图。



#### Ⅰ.参数解析器补充

26种参数解析器：

![1670242826653](E:\SpringBoot笔记\image\1670242826653.png)

确定将要执行的目标方法的每一个参数的值是什么;

SpringMVC目标方法能写多少种参数类型。取决于**参数解析器argumentResolvers**。

```java
@Nullable
protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
                                           HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

    ServletWebRequest webRequest = new ServletWebRequest(request, response);
    try {
        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);

        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
        //将参数解析器，设置到目标方法类中
        if (this.argumentResolvers != null) {//<--关注点
            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        }
        
        ...
       
```

this.argumentResolvers 在 afterPropertiesSet() 方法内初始化

```java
public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean {
	
    @Nullable
    private HandlerMethodArgumentResolverComposite argumentResolvers;
    
    @Override
    public void afterPropertiesSet() {
        ...
    	if (this.argumentResolvers == null) {//初始化argumentResolvers
        	List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();
            this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);
        }
        ...
    }

    //初始化了一堆的实现HandlerMethodArgumentResolver接口的
	private List<HandlerMethodArgumentResolver> getDefaultArgumentResolvers() {
		List<HandlerMethodArgumentResolver> resolvers = new ArrayList<>(30);

		// Annotation-based argument resolution
		resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), false));
		resolvers.add(new RequestParamMapMethodArgumentResolver());
		resolvers.add(new PathVariableMethodArgumentResolver());
		resolvers.add(new PathVariableMapMethodArgumentResolver());
		resolvers.add(new MatrixVariableMethodArgumentResolver());
		resolvers.add(new MatrixVariableMapMethodArgumentResolver());
		resolvers.add(new ServletModelAttributeMethodProcessor(false));
		resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));
		resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice));
		resolvers.add(new RequestHeaderMethodArgumentResolver(getBeanFactory()));
		resolvers.add(new RequestHeaderMapMethodArgumentResolver());
		resolvers.add(new ServletCookieValueMethodArgumentResolver(getBeanFactory()));
		resolvers.add(new ExpressionValueMethodArgumentResolver(getBeanFactory()));
		resolvers.add(new SessionAttributeMethodArgumentResolver());
		resolvers.add(new RequestAttributeMethodArgumentResolver());

		// Type-based argument resolution
		resolvers.add(new ServletRequestMethodArgumentResolver());
		resolvers.add(new ServletResponseMethodArgumentResolver());
		resolvers.add(new HttpEntityMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice));
		resolvers.add(new RedirectAttributesMethodArgumentResolver());
		resolvers.add(new ModelMethodProcessor());
		resolvers.add(new MapMethodProcessor());
		resolvers.add(new ErrorsMethodArgumentResolver());
		resolvers.add(new SessionStatusMethodArgumentResolver());
		resolvers.add(new UriComponentsBuilderMethodArgumentResolver());
		if (KotlinDetector.isKotlinPresent()) {
			resolvers.add(new ContinuationHandlerMethodArgumentResolver());
		}

		// Custom arguments
		if (getCustomArgumentResolvers() != null) {
			resolvers.addAll(getCustomArgumentResolvers());
		}

		// Catch-all
		resolvers.add(new PrincipalMethodArgumentResolver());
		resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true));
		resolvers.add(new ServletModelAttributeMethodProcessor(true));

		return resolvers;
	}
    
}
```

HandlerMethodArgumentResolverComposite 类如下：（众多**参数解析器argumentResolvers**的包装类）。

```java
public class HandlerMethodArgumentResolverComposite implements HandlerMethodArgumentResolver {

	private final List<HandlerMethodArgumentResolver> argumentResolvers = new ArrayList<>();
    
    ...
    
	public HandlerMethodArgumentResolverComposite addResolvers(@Nullable HandlerMethodArgumentResolver... resolvers) {

		if (resolvers != null) {
			Collections.addAll(this.argumentResolvers, resolvers);
		}
		return this;
	}
    
    ...
}
```

我们看看 HandlerMethodArgumentResolver 的源码：

```java
public interface HandlerMethodArgumentResolver {

    //当前解析器是否支持解析这种参数
	boolean supportsParameter(MethodParameter parameter);

	@Nullable//解析方法
	Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
			NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;

}

```



#### Ⅱ.返回值处理器补充

15种返回值处理器：

![1670244303743](E:\SpringBoot笔记\image\1670244303743.png)

**ValueHandler**

```java
@Nullable
protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
                                           HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

    ServletWebRequest webRequest = new ServletWebRequest(request, response);
    try {
        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);

        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
        if (this.argumentResolvers != null) {
            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
        }
        if (this.returnValueHandlers != null) {//<---关注点
            invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
        }
     ...

```

this.returnValueHandlers 在 afterPropertiesSet() 方法内初始化

```java
public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean {
	
	@Nullable
	private HandlerMethodReturnValueHandlerComposite returnValueHandlers;
    
	@Override
	public void afterPropertiesSet() {

        ...
        
		if (this.returnValueHandlers == null) {
			List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();
			this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
		}
	}
    
    //初始化了一堆的实现HandlerMethodReturnValueHandler接口的
    private List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers() {
		List<HandlerMethodReturnValueHandler> handlers = new ArrayList<>(20);

		// Single-purpose return value types
		handlers.add(new ModelAndViewMethodReturnValueHandler());
		handlers.add(new ModelMethodProcessor());
		handlers.add(new ViewMethodReturnValueHandler());
		handlers.add(new ResponseBodyEmitterReturnValueHandler(getMessageConverters(),
				this.reactiveAdapterRegistry, this.taskExecutor, this.contentNegotiationManager));
		handlers.add(new StreamingResponseBodyReturnValueHandler());
		handlers.add(new HttpEntityMethodProcessor(getMessageConverters(),
				this.contentNegotiationManager, this.requestResponseBodyAdvice));
		handlers.add(new HttpHeadersReturnValueHandler());
		handlers.add(new CallableMethodReturnValueHandler());
		handlers.add(new DeferredResultMethodReturnValueHandler());
		handlers.add(new AsyncTaskMethodReturnValueHandler(this.beanFactory));

		// Annotation-based return value types
		handlers.add(new ServletModelAttributeMethodProcessor(false));
		handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(),
				this.contentNegotiationManager, this.requestResponseBodyAdvice));

		// Multi-purpose return value types
		handlers.add(new ViewNameMethodReturnValueHandler());
		handlers.add(new MapMethodProcessor());

		// Custom return value types
		if (getCustomReturnValueHandlers() != null) {
			handlers.addAll(getCustomReturnValueHandlers());
		}

		// Catch-all
		if (!CollectionUtils.isEmpty(getModelAndViewResolvers())) {
			handlers.add(new ModelAndViewResolverMethodReturnValueHandler(getModelAndViewResolvers()));
		}
		else {
			handlers.add(new ServletModelAttributeMethodProcessor(true));
		}

		return handlers;
	}
}
```

 HandlerMethodReturnValueHandlerComposite 类如下：

```java
public class HandlerMethodReturnValueHandlerComposite implements HandlerMethodReturnValueHandler {

	private final List<HandlerMethodReturnValueHandler> returnValueHandlers = new ArrayList<>();

    ...
    
	public HandlerMethodReturnValueHandlerComposite addHandlers(
			@Nullable List<? extends HandlerMethodReturnValueHandler> handlers) {

		if (handlers != null) {
			this.returnValueHandlers.addAll(handlers);
		}
		return this;
	}

}
```

`HandlerMethodReturnValueHandler`接口：

```java
public interface HandlerMethodReturnValueHandler {
	
    //判断该参数是否支持被此返回值解析器解析
	boolean supportsReturnType(MethodParameter returnType);

    //解析方法
	void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,
			ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;

}
```

#### 4) 小结

本节描述，一个请求发送到DispatcherServlet后的具体处理流程，也就是SpringMVC的主要原理。

本节内容较多且硬核，对日后编程很有帮助，需耐心对待。

可以运行一个示例，打断点，在Debug模式下，查看程序流程。

(1) 请求进来到 DispatcherServlet 中的 doDispatch() 

(2) 执行 this.getHandler()，找到当前请求使用哪个Handler

(3) 执行 this.getHandlerAdapter()，为当前 Handler 找一个处理器映射器HandlerAdapter

(4) 执行 ha.handle() ，再进入 this.invokeHandlerMethod() 执行目标方法

​	创建一个目标方法类 invocableMethod。

​	(a) 获取参数解析器，设置到目标方法类中

​	(b) 获取返回值处理器，设置到目标方法类中

​	(c) invocableMethod.invokeAndHandle(),执行目标方法

​		(Ⅰ) **获取目标方法每一个参数的值**

​			(1)this.getMethodParameters(); 获取方法上 所有参数的详细信息（如：参数标记的注解，参数的索引位置，参数的类型）

​			(2)遍历参数列表,每一个参数都执行以下步骤

​				 (a) 获取指定参数解析器：this.resolvers.supportsParameter(parameter);

​					 判断之前设置的26种参数解析器 是否存在支持解析该参数的参数解析器。存在则，将该 参数及参数解析器 放入缓存中 

​				 (b) **解析参数：this.resolvers.resolveArgument();** 

​					 从缓存中获取上一步放入的参数解析器；

 					进行参数解析（每一种参数解析器，有着不同的解析方法，以上门例题中用的是PathVariableMethodArgumentResolver

​		(Ⅱ) 利用反射执行目标方法

​	

### 2. Servlet API参数解析原理

- WebRequest
- ServletRequest
- MultipartRequest
- HttpSession
- javax.servlet.http.PushBuilder
- Principal
- InputStream
- Reader
- HttpMethod
- Locale
- TimeZone
- ZoneId

**使用参数解析器：ServletRequestMethodArgumentResolver**用来处理以上的参数



案例演示

```java
@Controller
public class RequestController {

    @GetMapping("/goto")
    public String goToPage(HttpServletRequest request){

        request.setAttribute("msg","成功了...");
        request.setAttribute("code",200);
        return "forward:/success";  //转发到  /success请求
    }
}
```

浏览器调用 http://localhost:8888/goto



doDispatch() 的前部分内容在 第一节详细讲解，我们直接跳到下面 分析 (1) 和 (2) 

```java
//获取参数值
protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
   	//获取方法上 所有参数的详细信息（如：参数标记的注解，参数的索引位置，参数的类型）
    MethodParameter[] parameters = this.getMethodParameters();
    //判断参数列表是否为空
    if (ObjectUtils.isEmpty(parameters)) {
        return EMPTY_ARGS;
    } else {
        Object[] args = new Object[parameters.length];
		//遍历参数列表
        for(int i = 0; i < parameters.length; ++i) {
            MethodParameter parameter = parameters[i];
            parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
            args[i] = findProvidedArgument(parameter, providedArgs);
            if (args[i] == null) {
                //(1) 判断 之前设置的26种参数解析器 是否存在一种参数解析器 支持解析该参数
                if (!this.resolvers.supportsParameter(parameter)) {
                    throw new IllegalStateException(formatArgumentError(parameter, "No suitable resolver"));
                }

                try {
                    //(2) 支持的话就开始解析吧 <---------从此处开始分析
                    args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
                } catch (Exception var10) {
                    if (this.logger.isDebugEnabled()) {
                        String exMsg = var10.getMessage();
                        if (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {
                            this.logger.debug(formatArgumentError(parameter, exMsg));
                        }
                    }

                    throw var10;
                }
            }
        }

        return args;
    }
}
```



本例题的中的请求参数是HttpServletRequest 用ServletRequestMethodArgumentResolver参数解析器来处理的

#### (1) 判断参数解析器

循环参数所有的参数解析器，一 一判断是否可以解析这个参数，如果可以，就将该参数解析器放入缓存中（k-v，k为参数 v为参数解析器）。

下面分析 ServletRequestMethodArgumentResolver参数解析器，是如何判断 该参数是否能被它解析的：

```java
====================================== ServletRequestMethodArgumentResolver参数解析器 ===============================

//这个方法就是判断 参数parameter，是否支持被这个参数解析器解析
@Override
public boolean supportsParameter(MethodParameter parameter) {
    Class<?> paramType = parameter.getParameterType();
    return (WebRequest.class.isAssignableFrom(paramType) ||
            ServletRequest.class.isAssignableFrom(paramType) ||
            MultipartRequest.class.isAssignableFrom(paramType) ||
            HttpSession.class.isAssignableFrom(paramType) ||
            (pushBuilder != null && pushBuilder.isAssignableFrom(paramType)) ||
            (Principal.class.isAssignableFrom(paramType) && !parameter.hasParameterAnnotations()) ||
            InputStream.class.isAssignableFrom(paramType) ||
            Reader.class.isAssignableFrom(paramType) ||
            HttpMethod.class == paramType ||
            Locale.class == paramType ||
            TimeZone.class == paramType ||
            ZoneId.class == paramType);
}
```

#### (2) 开始解析

ServletRequestMethodArgumentResolver参数解析器，是如何解析该参数的，获取参数值的：

```java
===================================== ServletRequestMethodArgumentResolver参数解析器 ===============================

//该参数解析器的解析方法 
@Override
public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
                              NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {

    Class<?> paramType = parameter.getParameterType();
    
   
    //(1) 参数类型是否为这几种： WebRequest / NativeWebRequest / ServletWebRequest
    if (WebRequest.class.isAssignableFrom(paramType)) {
        if (!paramType.isInstance(webRequest)) {
            throw new IllegalStateException(
                "Current request is not of type [" + paramType.getName() + "]: " + webRequest);
        }
        //直接返回 webRequest 作为参数值
        return webRequest;
    }
    
    //(2) 参数类型是否为这几种：ServletRequest / HttpServletRequest / MultipartRequest / MultipartHttpServletRequest
    if (ServletRequest.class.isAssignableFrom(paramType) || MultipartRequest.class.isAssignableFrom(paramType)) {
        //(2.1) 获取原生的request请求，作为参数值
        return resolveNativeRequest(webRequest, paramType);
    }


    //(3) 其它参数类型的处理方式
    return resolveArgument(paramType, resolveNativeRequest(webRequest, HttpServletRequest.class));
}


//(2.1) 获取原生的request请求
private <T> T resolveNativeRequest(NativeWebRequest webRequest, Class<T> requiredType) {
    //拿到原生的request请求，返回
    T nativeRequest = webRequest.getNativeRequest(requiredType);
    if (nativeRequest == null) {
        throw new IllegalStateException(
            "Current request is not of type [" + requiredType.getName() + "]: " + webRequest);
    }
    return nativeRequest;
}


//(3) 其它参数类型的处理方式
@Nullable
private Object resolveArgument(Class<?> paramType, HttpServletRequest request) throws IOException {
    if (HttpSession.class.isAssignableFrom(paramType)) {
        HttpSession session = request.getSession();
        if (session != null && !paramType.isInstance(session)) {
            throw new IllegalStateException(
                "Current session is not of type [" + paramType.getName() + "]: " + session);
        }
        return session;
    }
    else if (pushBuilder != null && pushBuilder.isAssignableFrom(paramType)) {
        return PushBuilderDelegate.resolvePushBuilder(request, paramType);
    }
    else if (InputStream.class.isAssignableFrom(paramType)) {
        InputStream inputStream = request.getInputStream();
        if (inputStream != null && !paramType.isInstance(inputStream)) {
            throw new IllegalStateException(
                "Request input stream is not of type [" + paramType.getName() + "]: " + inputStream);
        }
        return inputStream;
    }
    else if (Reader.class.isAssignableFrom(paramType)) {
        Reader reader = request.getReader();
        if (reader != null && !paramType.isInstance(reader)) {
            throw new IllegalStateException(
                "Request body reader is not of type [" + paramType.getName() + "]: " + reader);
        }
        return reader;
    }
    else if (Principal.class.isAssignableFrom(paramType)) {
        Principal userPrincipal = request.getUserPrincipal();
        if (userPrincipal != null && !paramType.isInstance(userPrincipal)) {
            throw new IllegalStateException(
                "Current user principal is not of type [" + paramType.getName() + "]: " + userPrincipal);
        }
        return userPrincipal;
    }
    else if (HttpMethod.class == paramType) {
        return HttpMethod.resolve(request.getMethod());
    }
    else if (Locale.class == paramType) {
        return RequestContextUtils.getLocale(request);
    }
    else if (TimeZone.class == paramType) {
        TimeZone timeZone = RequestContextUtils.getTimeZone(request);
        return (timeZone != null ? timeZone : TimeZone.getDefault());
    }
    else if (ZoneId.class == paramType) {
        TimeZone timeZone = RequestContextUtils.getTimeZone(request);
        return (timeZone != null ? timeZone.toZoneId() : ZoneId.systemDefault());
    }

    // Should never happen...
    throw new UnsupportedOperationException("Unknown parameter type: " + paramType.getName());
}


/**
 * Inner class to avoid a hard dependency on Servlet API 4.0 at runtime.
 */
private static class PushBuilderDelegate {

    @Nullable
    public static Object resolvePushBuilder(HttpServletRequest request, Class<?> paramType) {
        PushBuilder pushBuilder = request.newPushBuilder();
        if (pushBuilder != null && !paramType.isInstance(pushBuilder)) {
            throw new IllegalStateException(
                "Current push builder is not of type [" + paramType.getName() + "]: " + pushBuilder);
        }
        return pushBuilder;

    }
}
```





### 3. Model、Map原理

复杂参数：

- **Map**
- **Model（ map、model里面的数据会被放在request的请求域  相对于request.setAttribute()向请求域存放数据 ）**
- Errors/BindingResult
- **RedirectAttributes（ 重定向携带数据）**
- **ServletResponse（response）**
- SessionStatus

- UriComponentsBuilder
- ServletUriComponentsBuilder



下面三位的数据都是被存放在request域中，可以用`request.getAttribute()`获取

Map<String,Object> map

Model model

HttpServletRequest request



接下来我们看看，Map<String,Object> map 与 Model model 用什么参数处理器。

**案例演示**

页面访问：http://localhost:8888/params

```java
@GetMapping("/params")
public String testParam(Map<String,Object> map,
                        Model model,
                        HttpServletRequest request,
                        HttpServletResponse response){
    
    //下面三位的数据都是存放在equest域中
    map.put("hello","world666");
    model.addAttribute("world","hello666");
    request.setAttribute("message","HelloWorld");

    Cookie cookie = new Cookie("c1","v1");
    response.addCookie(cookie);
    return "forward:/success";
}

@ResponseBody
@GetMapping("/success")
public Map success(HttpServletRequest request){
    Object msg1 = request.getAttribute("msg");
 
    Map<String,Object> map = new HashMap<>();
    Object hello = request.getAttribute("hello");//得出testParam方法赋予的值 world666
    Object world = request.getAttribute("world");//得出testParam方法赋予的值 hello666
    Object message = request.getAttribute("message");//得出testParam方法赋予的值 HelloWorld

    map.put("reqMethod_msg",msg1);
    map.put("annotation_msg",msg);
    
    map.put("hello",hello);
    map.put("world",world);
    map.put("message",message);

    return map;
}
```



doDispatch() 的前部分内容在 第一节详细讲解，我们直接跳到下面 分析 (1.1) 和 (1.2) 

```java
//获取参数值
protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
   	//获取方法上 所有参数的详细信息（如：参数标记的注解，参数的索引位置，参数的类型）
    MethodParameter[] parameters = this.getMethodParameters();
    //判断参数列表是否为空
    if (ObjectUtils.isEmpty(parameters)) {
        return EMPTY_ARGS;
    } else {
        Object[] args = new Object[parameters.length];
		//遍历参数列表
        for(int i = 0; i < parameters.length; ++i) {
            MethodParameter parameter = parameters[i];
            parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
            args[i] = findProvidedArgument(parameter, providedArgs);
            if (args[i] == null) {
                //(1.1) 判断 之前设置的26种参数解析器 是否存在一种参数解析器 支持解析该参数
                if (!this.resolvers.supportsParameter(parameter)) {
                    throw new IllegalStateException(formatArgumentError(parameter, "No suitable resolver"));
                }

                try {
                    //(1.2) 支持的话就开始解析吧 <---------从此处开始分析
                    args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
                } catch (Exception var10) {
                    if (this.logger.isDebugEnabled()) {
                        String exMsg = var10.getMessage();
                        if (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {
                            this.logger.debug(formatArgumentError(parameter, exMsg));
                        }
                    }

                    throw var10;
                }
            }
        }

        return args;
    }
}
```



#### 1) 判断参数解析器与解析参数

##### Map<String,Object> map 

##### (1) MapMethodProcessor参数解析器判断原理

```java
=============================================== MapMethodProcessor参数解析器 ===============================================

public class MapMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {

    
    //这个方法就是判断 参数parameter，是否支持被这个参数解析器解析
	@Override
	public boolean supportsParameter(MethodParameter parameter) {
        //判断是不是一个Map类型
		return (Map.class.isAssignableFrom(parameter.getParameterType()) &&
				parameter.getParameterAnnotations().length == 0);
	}
    
    ...
    
}
```



##### (2) MapMethodProcessor参数解析器获取参数值

```java
============================================ MapMethodProcessor参数解析器 ===============================================

//该参数解析器，解析参数的方法
@Override
@Nullable
public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
                              NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {

    Assert.state(mavContainer != null, "ModelAndViewContainer is required for model exposure");
    //从 ModelAndViewContainer 中获取 Model，作为参数值返回
    return mavContainer.getModel();
}


============================================== ModelAndViewContainer =================================================
    
public class ModelAndViewContainer {

    ...

	private final ModelMap defaultModel = new BindingAwareModelMap();

	@Nullable
	private ModelMap redirectModel;

    ...

    //getModel()
	public ModelMap getModel() {
		if (useDefaultModel()) {
			return this.defaultModel;
		}
		else {
			if (this.redirectModel == null) {
				this.redirectModel = new ModelMap();
			}
			return this.redirectModel;
		}
	}
    
    ...
    
}
```



---

##### Model model 

##### (1) ModelMethodProcessor参数解析器判断依据

```java
=============================================== ModelMethodProcessor参数解析器 ===============================================

public class ModelMethodProcessor implements HandlerMethodArgumentResolver, HandlerMethodReturnValueHandler {

    
	@Override
	public boolean supportsParameter(MethodParameter parameter) {
		return Model.class.isAssignableFrom(parameter.getParameterType());
	}

}
```

##### (2) ModelMethodProcessor参数解析器获取参数值

```java
============================================ ModelMethodProcessor参数解析器 ===========================================
    
//该参数解析器，解析参数的方法
@Override
@Nullable
public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,
                              NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {

    Assert.state(mavContainer != null, "ModelAndViewContainer is required for model exposure");
    //从 ModelAndViewContainer 中获取 Model，作为参数值返回
    return mavContainer.getModel();
}


============================================== ModelAndViewContainer =================================================
    
public class ModelAndViewContainer {

    ...

	private final ModelMap defaultModel = new BindingAwareModelMap();

	@Nullable
	private ModelMap redirectModel;

    ...

    //getModel()
	public ModelMap getModel() {
		if (useDefaultModel()) {
			return this.defaultModel;
		}
		else {
			if (this.redirectModel == null) {
				this.redirectModel = new ModelMap();
			}
			return this.redirectModel;
		}
	}
    
    ...
    
}
```



**两个参数解析器，解析参数值的原理是一模一样**

Model 也是另一种意义的 Map ：

![在这里插入图片描述](image/20210205010247689.png)

`

---

#### 2) 如何通过 request.getAttribute()获取参数值



我们直接跳到,执行完例题中的第一个控制器方法，分析:如何处理返回结果("forward:/success")

```java
========================================== ServletInvocableHandlerMethod =================================

public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
    //执行完目标方法，returnValue = "forward:/success"
    Object returnValue = this.invokeForRequest(webRequest, mavContainer, providedArgs);
    //设置相应状态
    this.setResponseStatus(webRequest);
    
    if (returnValue == null) {
        if (this.isRequestNotModified(webRequest) || this.getResponseStatus() != null || mavContainer.isRequestHandled()) {
            this.disableContentCachingIfNecessary(webRequest);
            mavContainer.setRequestHandled(true);
            return;
        }
    } else if (StringUtils.hasText(this.getResponseStatusReason())) {
        mavContainer.setRequestHandled(true);
        return;
    }

    mavContainer.setRequestHandled(false);
    Assert.state(this.returnValueHandlers != null, "No return value handlers");

    try {
        //处理 执行控制器方法的返回结果          <-- 从这里开始分析
        this.returnValueHandlers.handleReturnValue(returnValue, this.getReturnValueType(returnValue), mavContainer, webRequest);
    } catch (Exception var6) {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace(this.formatErrorForReturnValue(returnValue), var6);
        }

        throw var6;
    }
    
}
```



众所周知，所有的数据都放在 **ModelAndView** 包含要去的页面地址View，还包含Model数据。

先看 **ModelAndView** 接下来是如何处理的？

```java
====================================== HandlerMethodReturnValueHandlerComposite ===========================

public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
    //获取返回值处理器（后面讲解响应处理时细讲）
    HandlerMethodReturnValueHandler handler = this.selectHandler(returnValue, returnType);
    if (handler == null) {
        throw new IllegalArgumentException("Unknown return value type: " + returnType.getParameterType().getName());
    } else {
        //继续进入这个方法分析		
        handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
    }
}

====================================== ViewNameMethodReturnValueHandler ====================================

public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
    //判断 如果返回值是一个字符串类型
    if (returnValue instanceof CharSequence) {
        //拿到这个返回值（"forward:/success"）
        String viewName = returnValue.toString();
        //保存到一个ModelAndViewContainer(模型和视图容器)中
        mavContainer.setViewName(viewName);
        if (this.isRedirectViewName(viewName)) {
            mavContainer.setRedirectModelScenario(true);
        }
    } else if (returnValue != null) {
        throw new UnsupportedOperationException("Unexpected return type: " + returnType.getParameterType().getName() + " in method: " + returnType.getMethod());
    }

}
```

目标方法执行完成，会将所有的数据都存放在 ModelAndViewContainer中：包含要去的页面地址view,还包含model数据

![1670511093210](C:\Users\huach\AppData\Roaming\Typora\typora-user-images\1670511093210.png)

得到响应数据后 跳出 ServletInvocableHandlerMethod(本节起始位置) ，开始要处理响应的数据了

```java
======================================= ResquestMapperHandlerAdapter =================================================
//进入
var15 = this.getModelAndView(mavContainer, modelFactory, webRequest);

    
@Nullable
private ModelAndView getModelAndView(ModelAndViewContainer mavContainer, ModelFactory modelFactory, NativeWebRequest webRequest) throws Exception {
    //(1) 更新Modle
    modelFactory.updateModel(webRequest, mavContainer);
    if (mavContainer.isRequestHandled()) {
        return null;
    } else {
        //获取modle
        ModelMap model = mavContainer.getModel();
        //将view 和 model 封装成一个ModelAndView
        ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus());
        if (!mavContainer.isViewReference()) {
            mav.setView((View)mavContainer.getView());
        }
		//如果你的model是 重定向携带数据
        if (model instanceof RedirectAttributes) {
            Map<String, ?> flashAttributes = ((RedirectAttributes)model).getFlashAttributes();
            HttpServletRequest request = (HttpServletRequest)webRequest.getNativeRequest(HttpServletRequest.class);
            if (request != null) {
                RequestContextUtils.getOutputFlashMap(request).putAll(flashAttributes);
            }
        }
		//返回mav
        return mav;
    }
}

=========================================== modelFactory ============================================
//(1) 更新Modle
public void updateModel(NativeWebRequest request, ModelAndViewContainer container) throws Exception {
    //获取默认容器中默认的Model（包含model数据）
    ModelMap defaultModel = container.getDefaultModel();
    if (container.getSessionStatus().isComplete()) {
        this.sessionAttributesHandler.cleanupAttributes(request);
    } else {
        this.sessionAttributesHandler.storeAttributes(request, defaultModel);
    }

    if (!container.isRequestHandled() && container.getModel() == defaultModel) {
        //(1.1)更新绑定结果
        this.updateBindingResult(request, defaultModel);
    }

}

//(1.1)更新绑定结果
private void updateBindingResult(NativeWebRequest request, ModelMap model) throws Exception {
    //获取model中所有的key（hello、world）
    List<String> keyNames = new ArrayList(model.keySet());
    Iterator var4 = keyNames.iterator();
	
    //遍历，取每个key对应的值
    while(var4.hasNext()) {
        String name = (String)var4.next();
        Object value = model.get(name);
        if (value != null && this.isBindingCandidate(name, value)) {
            String bindingResultKey = BindingResult.MODEL_KEY_PREFIX + name;
            if (!model.containsAttribute(bindingResultKey)) {
                WebDataBinder dataBinder = this.dataBinderFactory.createBinder(request, value, name);
                model.put(bindingResultKey, dataBinder.getBindingResult());
            }
        }
    }

}

```

处理完响应数据，返回到 DispatcherService 的 doDispatch()

```java
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HttpServletRequest processedRequest = request;
    HandlerExecutionChain mappedHandler = null;
    boolean multipartRequestParsed = false;
    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

    try {
        try {
            ModelAndView mv = null;
            Exception dispatchException = null;

            try {
                processedRequest = this.checkMultipart(request);
                multipartRequestParsed = processedRequest != request;
                //获取handler
                mappedHandler = this.getHandler(processedRequest);
                if (mappedHandler == null) {
                    this.noHandlerFound(processedRequest, response);
                    return;
                }

               	//获取处理器适配器
                HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());
                String method = request.getMethod();
                boolean isGet = "GET".equals(method);
                if (isGet || "HEAD".equals(method)) {
                    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                    if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) && isGet) {
                        return;
                    }
                }

                if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                    return;
                }

                //执行目标方法  <--上一步是从这里出来的哦
                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
                if (asyncManager.isConcurrentHandlingStarted()) {
                    return;
                }
			
                this.applyDefaultViewName(processedRequest, mv);
                
                //拦截器相关处理
                mappedHandler.applyPostHandle(processedRequest, response, mv);
            } catch (Exception var20) {
                dispatchException = var20;
            } catch (Throwable var21) {
                dispatchException = new NestedServletException("Handler dispatch failed", var21);
            }

            //(1) 处理完响应数据 之后的核心代码在在里面，处理派发结果
            this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);
        } catch (Exception var22) {
            this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);
        } catch (Throwable var23) {
            this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", var23));
        }

    } finally {
        if (asyncManager.isConcurrentHandlingStarted()) {
            if (mappedHandler != null) {
                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
            }
        } else if (multipartRequestParsed) {
            this.cleanupMultipart(processedRequest);
        }

    }
}

//(1) 处理派发结果
private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception {
    boolean errorView = false;
    if (exception != null) {
        if (exception instanceof ModelAndViewDefiningException) {
            this.logger.debug("ModelAndViewDefiningException encountered", exception);
            mv = ((ModelAndViewDefiningException)exception).getModelAndView();
        } else {
            Object handler = mappedHandler != null ? mappedHandler.getHandler() : null;
            mv = this.processHandlerException(request, response, handler, exception);
            errorView = mv != null;
        }
    }
	
    if (mv != null && !mv.wasCleared()) {
        //(1.1) 页面渲染
        this.render(mv, request, response);
        if (errorView) {
            WebUtils.clearErrorRequestAttributes(request);
        }
    } else if (this.logger.isTraceEnabled()) {
        this.logger.trace("No view rendering, null ModelAndView returned.");
    }

    if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {
        if (mappedHandler != null) {
            mappedHandler.triggerAfterCompletion(request, response, (Exception)null);
        }

    }
}

//(1.1) 页面渲染 this.render()
protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception {
    Locale locale = this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale();
    response.setLocale(locale);
    String viewName = mv.getViewName();
    View view;
    if (viewName != null) {
        //解析视图
        view = this.resolveViewName(viewName, mv.getModelInternal(), locale, request);
        if (view == null) {
            throw new ServletException("Could not resolve view with name '" + mv.getViewName() + "' in servlet with name '" + this.getServletName() + "'");
        }
    } else {
        view = mv.getView();
        if (view == null) {
            throw new ServletException("ModelAndView [" + mv + "] neither contains a view name nor a View object in servlet with name '" + this.getServletName() + "'");
        }
    }

    if (this.logger.isTraceEnabled()) {
        this.logger.trace("Rendering view [" + view + "] ");
    }

    try {
        if (mv.getStatus() != null) {
            response.setStatus(mv.getStatus().value());
        }
		//(1.1.1)视图渲染 
        view.render(mv.getModelInternal(), request, response);
    } catch (Exception var8) {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Error rendering view [" + view + "]", var8);
        }

        throw var8;
    }
}

=========================================== AbstractView ========================================================
//(1.1.1)视图渲染   
public void render(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception {
    if (this.logger.isDebugEnabled()) {
        this.logger.debug("View " + this.formatViewName() + ", model " + (model != null ? model : Collections.emptyMap()) + (this.staticAttributes.isEmpty() ? "" : ", static attributes " + this.staticAttributes));
    }
	//(a)创建一个 合并输出的模型
    Map<String, Object> mergedModel = this.createMergedOutputModel(model, request, response);
    //准备响应
    this.prepareResponse(request, response);
    //(b)渲染 合并输出的模型 中的数据
    this.renderMergedOutputModel(mergedModel, this.getRequestToExpose(request), response);
}

//(a)创建一个要合并输出的模型
protected Map<String, Object> createMergedOutputModel(@Nullable Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) {
    Map<String, Object> pathVars = this.exposePathVariables ? (Map)request.getAttribute(View.PATH_VARIABLES) : null;
    int size = this.staticAttributes.size();
    size += model != null ? model.size() : 0;
    size += pathVars != null ? pathVars.size() : 0;
    Map<String, Object> mergedModel = new LinkedHashMap(size);
    mergedModel.putAll(this.staticAttributes);
    if (pathVars != null) {
        mergedModel.putAll(pathVars);
    }

    if (model != null) {
        //将model中的数据放到mergedModel中，（mergedModel是一个LinkdHashMap）
        mergedModel.putAll(model);
    }

    if (this.requestContextAttribute != null) {
        mergedModel.put(this.requestContextAttribute, this.createRequestContext(request, response, mergedModel));
    }

    return mergedModel;
}

======================================== InternalResourceView ===========================================
//(b)渲染 合并输出的模型 中的数据
protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {
    //(b.1) 暴露模型作为请求域的属性
    this.exposeModelAsRequestAttributes(model, request);
    this.exposeHelpers(request);
    String dispatcherPath = this.prepareForRendering(request, response);
    RequestDispatcher rd = this.getRequestDispatcher(request, dispatcherPath);
    if (rd == null) {
        throw new ServletException("Could not get RequestDispatcher for [" + this.getUrl() + "]: Check that the corresponding file exists within your web application archive!");
    } else {
        if (this.useInclude(request, response)) {
            response.setContentType(this.getContentType());
            if (this.logger.isDebugEnabled()) {
                this.logger.debug("Including [" + this.getUrl() + "]");
            }

            rd.include(request, response);
        } else {
            if (this.logger.isDebugEnabled()) {
                this.logger.debug("Forwarding to [" + this.getUrl() + "]");
            }

            rd.forward(request, response);
        }

    }
}

=========================================== AbstractView ===============================================
//(b.1) 暴露模型作为请求域的属性
protected void exposeModelAsRequestAttributes(Map<String, Object> model, HttpServletRequest request) throws Exception {
    //将model中所有的数据遍历，设置到request中 ( model中的数据：{"hello":"world666","world":"hello666"} )
    model.forEach((name, value) -> {
        if (value != null) {
            request.setAttribute(name, value);
        } else {
            request.removeAttribute(name);
        }

    });
}
```

exposeModelAsRequestAttributes 方法看出， Map<String,Object> map ， Model model 这两种类型数据可以给request域中放数据，用 request.getAttribute()获取。



### 4. 自定义参数绑定原理

```java
@RestController
public class ParameterTestController {

    /**
     * 数据绑定：页面提交的请求数据（GET、POST）都可以和对象属性进行绑定
     * @param person
     * @return
     */
    @PostMapping("/saveuser")
    public Person saveuser(Person person){
        return person;
    }
}
```

saveuser



```java

/**
 *	页面提交的数据,可以直接封装成 一个对象
 *
 *     姓名： <input name="userName"/> <br/>
 *     年龄： <input name="age"/> <br/>
 *     生日： <input name="birth"/> <br/>
 *     宠物姓名：<input name="pet.name"/><br/>
 *     宠物年龄：<input name="pet.age"/>
 */
@Data
public class Person {
    
    private String userName;
    private Integer age;
    private Date birth;
    private Pet pet;
    
}

@Data
public class Pet {

    private String name;
    private String age;

}
```



doDispatch() 的前部分内容在 第一节详细讲解，我们直接跳到下面 分析 (1) 和 (2) 

```java
//获取参数值
protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
   	//获取方法上 所有参数的详细信息（如：参数标记的注解，参数的索引位置，参数的类型）
    MethodParameter[] parameters = this.getMethodParameters();
    //判断参数列表是否为空
    if (ObjectUtils.isEmpty(parameters)) {
        return EMPTY_ARGS;
    } else {
        Object[] args = new Object[parameters.length];
		//遍历参数列表
        for(int i = 0; i < parameters.length; ++i) {
            MethodParameter parameter = parameters[i];
            parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);
            args[i] = findProvidedArgument(parameter, providedArgs);
            if (args[i] == null) {
                
                //(1) 判断 之前设置的26种参数解析器 是否存在一种参数解析器 支持解析该参数
                if (!this.resolvers.supportsParameter(parameter)) {
                    throw new IllegalStateException(formatArgumentError(parameter, "No suitable resolver"));
                }

                try {
                    //(2) 支持的话就开始解析吧 <---------从此处开始分析
                    args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);
                } catch (Exception var10) {
                    if (this.logger.isDebugEnabled()) {
                        String exMsg = var10.getMessage();
                        if (exMsg != null && !exMsg.contains(parameter.getExecutable().toGenericString())) {
                            this.logger.debug(formatArgumentError(parameter, exMsg));
                        }
                    }

                    throw var10;
                }
            }
        }

        return args;
    }
}
```



自定义类型的参数使用这个参数解析器解析 ServletModelAttributeMethodProcessor

#### (1) 判断参数解析器

循环参数所有的参数解析器，一 一判断是否可以解析这个参数，如果可以，就将该参数解析器放入缓存中（k-v，k为参数 v为参数解析器）

下面分析ServletModelAttributeMethodProcessor参数解析器，判断原理

```java
===================================== ServletModelAttributeMethodProcessor =======================================

public class ServletModelAttributeMethodProcessor extends ModelAttributeMethodProcessor {
	
    //判断这个参数解析器是否支持解析这个参数
    @Override
	public boolean supportsParameter(MethodParameter parameter) {
        //(1) （参数标注了@ModelAttribute注解）||（参数不是必须的 && 不是简单属性）
		return (parameter.hasParameterAnnotation(ModelAttribute.class) ||
				(this.annotationNotRequired && !BeanUtils.isSimpleProperty(parameter.getParameterType())));
	}

	...
}

//(1.1)不是简单属性: !BeanUtils.isSimpleProperty(parameter.getParameterType())
//(a) parameter.getParameterType()：获取参数的类型信息
//(b) BeanUtils.isSimpleProperty(参数的类型信息):
public static boolean isSimpleProperty(Class<?> type) {
    Assert.notNull(type, "'type' must not be null");
    //判断
    return isSimpleValueType(type) || type.isArray() && isSimpleValueType(type.getComponentType());
}

//isSimpleValueType(type.getComponentType())：
public static boolean isSimpleValueType(Class<?> type) {
    return Void.class != type 
        && Void.TYPE != type 
        && (ClassUtils.isPrimitiveOrWrapper(type) 
            || Enum.class.isAssignableFrom(type) 
            || CharSequence.class.isAssignableFrom(type) 
            || Number.class.isAssignableFrom(type) 
            || Date.class.isAssignableFrom(type) 
            || Temporal.class.isAssignableFrom(type) 
            || URI.class == type || URL.class == type 
            || Locale.class == type 
            || Class.class == type);
}
```



#### (2) 开始解析

args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);

```java
===================================== HandlerMethodArgumentResolverComposite ==============================

@Nullable
public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
    //从缓存中获取 刚刚保存的参数解析器
    HandlerMethodArgumentResolver resolver = this.getArgumentResolver(parameter);
    if (resolver == null) {
        throw new IllegalArgumentException("Unsupported parameter type [" + parameter.getParameterType().getName() + "]. supportsParameter should be called first.");
    } else {
        return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);
    }
}

============================================= ServletModelAttributeMethodProcessor =======================================

@Nullable
public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer, NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {
    
    Assert.state(mavContainer != null, "ModelAttributeMethodProcessor requires ModelAndViewContainer");
    Assert.state(binderFactory != null, "ModelAttributeMethodProcessor requires WebDataBinderFactory");
    //获取参数名("person")
    String name = ModelFactory.getNameForParameter(parameter);
    //获取参数的ModelAttribute注解（本例题没有标注）
    ModelAttribute ann = (ModelAttribute)parameter.getParameterAnnotation(ModelAttribute.class);
    if (ann != null) {
        mavContainer.setBinding(name, ann.binding());
    }

    Object attribute = null;
    BindingResult bindingResult = null;
    //如果ModelAndView容器中存在名为name的对象（person对象），就获取
    if (mavContainer.containsAttribute(name)) {
        attribute = mavContainer.getModel().get(name);
    } else {
        try {
            //创建一个对象 (person对象)
            attribute = this.createAttribute(name, parameter, binderFactory, webRequest);
        } catch (BindException var10) {
            if (this.isBindExceptionRequired(parameter)) {
                throw var10;
            }

            if (parameter.getParameterType() == Optional.class) {
                attribute = Optional.empty();
            }

            bindingResult = var10.getBindingResult();
        }
    }

    if (bindingResult == null) {
        
        /**
          *	创建 WebDataBinder (web数据绑定器，作用是 将webRequest中的数据，绑定到指定的JavaBean中)
          *
          * webRequest：原生的webRequest请求，携带着所有请求数据（包括以POST请求发送的所有数据）
          * attribute：刚刚创建的空对象
          * name：参数名
         */
        WebDataBinder binder = binderFactory.createBinder(webRequest, attribute, name);
        if (binder.getTarget() != null) {
            if (!mavContainer.isBindingDisabled(name)) {
                //(1)这个方法，就是利用binder中的对应的converter类型类型转换器 将webRequest中的数据，转换成对应的数据类型
                //并将这些数据封装到 bander中的targel对象中(person对象)
                this.bindRequestParameters(binder, webRequest);
            }

            this.validateIfApplicable(binder, parameter);
            if (binder.getBindingResult().hasErrors() && this.isBindExceptionRequired(binder, parameter)) {
                throw new BindException(binder.getBindingResult());
            }
        }

        if (!parameter.getParameterType().isInstance(attribute)) {
            attribute = binder.convertIfNecessary(binder.getTarget(), parameter.getParameterType(), parameter);
        }

        bindingResult = binder.getBindingResult();
    }

    Map<String, Object> bindingResultModel = bindingResult.getModel();
    mavContainer.removeAttributes(bindingResultModel);
    mavContainer.addAllAttributes(bindingResultModel);
    return attribute;
}

======================================== ServletModelAttributeMethodProcessor ==================================

//(1) this.bindRequestParameters(binder, webRequest);
protected void bindRequestParameters(WebDataBinder binder, NativeWebRequest request) {
    //获取原生servletRequest
    ServletRequest servletRequest = (ServletRequest)request.getNativeRequest(ServletRequest.class);
    Assert.state(servletRequest != null, "No ServletRequest");
    //将WebDataBinder转换为ServletRequestDataBinder
    ServletRequestDataBinder servletBinder = (ServletRequestDataBinder)binder;
    //(1.1) 将请求中的数据绑定到servletBinder中
    servletBinder.bind(servletRequest);
}

======================================= ServletRequestDataBinder ===========================================
//(1.1) servletBinder.bind()
public void bind(ServletRequest request) {
    //获取request中 所有请求参数（每一个请求参数都封装成了一个propertyValue（k-v））
    MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);
    MultipartRequest multipartRequest = (MultipartRequest)WebUtils.getNativeRequest(request, MultipartRequest.class);
    if (multipartRequest != null) {
        this.bindMultipart(multipartRequest.getMultiFileMap(), mpvs);
    }

 	//添加 绑定的值
    this.addBindValues(mpvs, request);
    //(a)开始绑定
    this.doBind(mpvs);
}

======================================= WebDataBinder ======================================================
//(a)开始绑定
protected void doBind(MutablePropertyValues mpvs) {
     this.checkFieldDefaults(mpvs);
     this.checkFieldMarkers(mpvs);
     //进入 <--
     super.doBind(mpvs);
}


======================================= DataBinder ======================================================
protected void doBind(MutablePropertyValues mpvs) {
    this.checkAllowedFields(mpvs);
    this.checkRequiredFields(mpvs);
    //应用PropertyValues中存放的属性 <--
    this.applyPropertyValues(mpvs);
}
	

protected void applyPropertyValues(MutablePropertyValues mpvs) {
    try {
        //设置属性值 <--
        this.getPropertyAccessor().setPropertyValues(mpvs, this.isIgnoreUnknownFields(), this.isIgnoreInvalidFields());
    } catch (PropertyBatchUpdateException var7) {
        PropertyAccessException[] var3 = var7.getPropertyAccessExceptions();
        int var4 = var3.length;

        for(int var5 = 0; var5 < var4; ++var5) {
            PropertyAccessException pae = var3[var5];
            this.getBindingErrorProcessor().processPropertyAccessException(pae, this.getInternalBindingResult());
        }
    }
}


======================================= AbstractPropertyAccessor ================================================
    
public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid) throws BeansException {
    List<PropertyAccessException> propertyAccessExceptions = null;
    List<PropertyValue> propertyValues = pvs instanceof MutablePropertyValues ? ((MutablePropertyValues)pvs).getPropertyValueList() : Arrays.asList(pvs.getPropertyValues());
    Iterator var6 = propertyValues.iterator();

    //遍历 pvs(所有属性)
    while(var6.hasNext()) {
        PropertyValue pv = (PropertyValue)var6.next();

        try {
            //设置属性值 <--
            this.setPropertyValue(pv);
        } catch (NotWritablePropertyException var9) {
            if (!ignoreUnknown) {
                throw var9;
            }
        } catch (NullValueInNestedPathException var10) {
            if (!ignoreInvalid) {
                throw var10;
            }
        } catch (PropertyAccessException var11) {
            if (propertyAccessExceptions == null) {
                propertyAccessExceptions = new ArrayList();
            }

            propertyAccessExceptions.add(var11);
        }
    }

    if (propertyAccessExceptions != null) {
        PropertyAccessException[] paeArray = (PropertyAccessException[])propertyAccessExceptions.toArray(new PropertyAccessException[0]);
        throw new PropertyBatchUpdateException(paeArray);
    }
}


===================================== AbstractNestablePropertyAccessor ========================================

//设置属性值 <--
//this.setPropertyValue(pv);
public void setPropertyValue(PropertyValue pv) throws BeansException {
    PropertyTokenHolder tokens = (PropertyTokenHolder)pv.resolvedTokens;
    if (tokens == null) {
        String propertyName = pv.getName();

        AbstractNestablePropertyAccessor nestedPa;
        try {
            //获取一个BeanWpperImpl（包装了指定绑定的JavaBean（person） ）
            nestedPa = this.getPropertyAccessorForPropertyPath(propertyName);
        } catch (NotReadablePropertyException var6) {
            throw new NotWritablePropertyException(this.getRootClass(), this.nestedPath + propertyName, "Nested property in path '" + propertyName + "' does not exist", var6);
        }

        tokens = this.getPropertyNameTokens(this.getFinalPath(nestedPa, propertyName));
        if (nestedPa == this) {
            pv.getOriginalPropertyValue().resolvedTokens = tokens;
        }
	
       	//调用BeanWpperImpl的方法，将属性值 设置到 JavaBean中 <--
        nestedPa.setPropertyValue(tokens, pv);
    } else {
        
        this.setPropertyValue(tokens, pv);
    }

}


//nestedPa.setPropertyValue(tokens, pv);
protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {
    if (tokens.keys != null) {
        this.processKeyedProperty(tokens, pv);
    } else {
        // <--
        this.processLocalProperty(tokens, pv);
    }

}

//this.processLocalProperty(tokens, pv);
private void processLocalProperty(PropertyTokenHolder tokens, PropertyValue pv) {
    PropertyHandler ph = this.getLocalPropertyHandler(tokens.actualName);
    if (ph != null && ph.isWritable()) {
        Object oldValue = null;

        PropertyChangeEvent propertyChangeEvent;
        try {
            Object originalValue = pv.getValue();
            Object valueToApply = originalValue;
            if (!Boolean.FALSE.equals(pv.conversionNecessary)) {
                if (pv.isConverted()) {
                    //获取属性值 (第一个属性为 age，他的值为"18"(所有参数值都是字符串类型) )
                    valueToApply = pv.getConvertedValue();
                } else {
                    if (this.isExtractOldValueForEditor() && ph.isReadable()) {
                        try {
                            oldValue = ph.getValue();
                        } catch (Exception var8) {
                            Exception ex = var8;
                            if (var8 instanceof PrivilegedActionException) {
                                ex = ((PrivilegedActionException)var8).getException();
                            }

                            if (logger.isDebugEnabled()) {
                                logger.debug("Could not read previous value of property '" + this.nestedPath + tokens.canonicalName + "'", ex);
                            }
                        }
                    }
                    
					//类型转换（ 将得到的属性值(String)转换为相应的数据类型 ） <--
                    valueToApply = this.convertForProperty(tokens.canonicalName, oldValue, originalValue, ph.toTypeDescriptor());
                }

                pv.getOriginalPropertyValue().conversionNecessary = valueToApply != originalValue;
            }

            //将转换换好的属性值，设置进去 《==========================(本节分析的终点)==============================
            ph.setValue(valueToApply);
       
            ...
}

//类型转换（ 将得到的属性值(String)转换为相应的数据类型 ）
@Nullable
protected Object convertForProperty(String propertyName, @Nullable Object oldValue, @Nullable Object newValue, TypeDescriptor td) throws TypeMismatchException {
    // <--
    return this.convertIfNecessary(propertyName, oldValue, newValue, td.getType(), td);
}

//<--
@Nullable
private Object convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, @Nullable Class<?> requiredType, @Nullable TypeDescriptor td) throws TypeMismatchException {
    Assert.state(this.typeConverterDelegate != null, "No TypeConverterDelegate");

    PropertyChangeEvent pce;
    try {
        //this.typeConverterDelegate获取转换器的代理对象，里面包含了124个转换器
        //调用convertIfNecessary(),类型转换 <--
        return this.typeConverterDelegate.convertIfNecessary(propertyName, oldValue, newValue, requiredType, td);
  	...
}

============================================ TypeConverterDelegate =============================================
//<--
@Nullable
public <T> T convertIfNecessary(@Nullable String propertyName, @Nullable Object oldValue, @Nullable Object newValue, @Nullable Class<T> requiredType, @Nullable TypeDescriptor typeDescriptor) throws IllegalArgumentException {
    PropertyEditor editor = this.propertyEditorRegistry.findCustomEditor(requiredType, propertyName);
    ConversionFailedException conversionAttemptEx = null;
    //获取conversionService转换工具，里面有124个类型转换器
    ConversionService conversionService = this.propertyEditorRegistry.getConversionService();
    if (editor == null && conversionService != null && newValue != null && typeDescriptor != null) {
        TypeDescriptor sourceTypeDesc = TypeDescriptor.forObject(newValue);
        //（a）在转换工具内找可以 对该属性值进行转换 的转换器，可以找到返回true <--
        if (conversionService.canConvert(sourceTypeDesc, typeDescriptor)) {
            try {
                //(b) 到这里我们已经找到了合适的转换器，调用转换工具的转换方法 <--
                return conversionService.convert(newValue, sourceTypeDesc, typeDescriptor);
            } catch (ConversionFailedException var14) {
                conversionAttemptEx = var14;
            }
        }
    }
	
    ...

    return convertedValue;
}


==================================== GenericConversionService ================================================


```

(a)在转换工具中 可以可以拿到那个合适的转换器

```java
//(1)能不能获取到合适的转换器
public boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {
    Assert.notNull(targetType, "Target type to convert to cannot be null");
    if (sourceType == null) {
        return true;
    } else {
        //获取转换器 <--
        GenericConverter converter = this.getConverter(sourceType, targetType);
        return converter != null;
    }
}

//获取转换器
@Nullable
protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {
    ConverterCacheKey key = new ConverterCacheKey(sourceType, targetType);
    //先去缓存中找转换器
    GenericConverter converter = (GenericConverter)this.converterCache.get(key);
    if (converter != null) {
        return converter != NO_MATCH ? converter : null;
    } else {
        //在124个转换器中找 (遍历循环，看看那个合适)
        converter = this.converters.find(sourceType, targetType);
        if (converter == null) {
            converter = this.getDefaultConverter(sourceType, targetType);
        }

        if (converter != null) {
            this.converterCache.put(key, converter);
            return converter;
        } else {
            this.converterCache.put(key, NO_MATCH);
            return null;
        }
    }
}

//在124个转换器中找 (遍历循环，看看那个合适) <--
@Nullable
public GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) {
    List<Class<?>> sourceCandidates = this.getClassHierarchy(sourceType.getType());
    List<Class<?>> targetCandidates = this.getClassHierarchy(targetType.getType());
    Iterator var5 = sourceCandidates.iterator();

    while(var5.hasNext()) {
        Class<?> sourceCandidate = (Class)var5.next();
        Iterator var7 = targetCandidates.iterator();

        while(var7.hasNext()) {
            Class<?> targetCandidate = (Class)var7.next();
            GenericConverter.ConvertiblePair convertiblePair = new GenericConverter.ConvertiblePair(sourceCandidate, targetCandidate);
            GenericConverter converter = this.getRegisteredConverter(sourceType, targetType, convertiblePair);
            if (converter != null) {
                return converter;
            }
        }
    }

    return null;
}

```

(b) 到这里我们已经找到了合适的转换器，调用转换工具的转换方法 

```java

/**
 * source：原属性值
 * sourceType：原属性的类型(String)
 * targetType：需要转换的目标类型
 */
@Nullable
public Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {
    Assert.notNull(targetType, "Target type to convert to cannot be null");
    if (sourceType == null) {
        Assert.isTrue(source == null, "Source must be [null] if source type == [null]");
        return this.handleResult((TypeDescriptor)null, targetType, this.convertNullSource((TypeDescriptor)null, targetType));
    } else if (source != null && !sourceType.getObjectType().isInstance(source)) {
        throw new IllegalArgumentException("Source to convert from must be an instance of [" + sourceType + "]; instead it was a [" + source.getClass().getName() + "]");
    } else {
        //获取那个合适的转换器
        GenericConverter converter = this.getConverter(sourceType, targetType);
        if (converter != null) {
            //使用它的转换工具，进行转换 <--
            Object result = ConversionUtils.invokeConverter(converter, source, sourceType, targetType);
            return this.handleResult(sourceType, targetType, result);
        } else {
            return this.handleConverterNotFound(source, sourceType, targetType);
        }
    }
}

//调用转换工具的方法，进行转换
@Nullable
public static Object invokeConverter(GenericConverter converter, @Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
    try {
        //调用转换器的转换方法 <--
        return converter.convert(source, sourceType, targetType);
    } catch (ConversionFailedException var5) {
        throw var5;
    } catch (Throwable var6) {
        throw new ConversionFailedException(sourceType, targetType, source, var6);
    }
}

============================= StringToNumberConverterFactory ==============================================
public T convert(String source) {
    return source.isEmpty() ? null : NumberUtils.parseNumber(source, this.targetType);
}

//NumberUtils.parseNumber()
public static <T extends Number> T parseNumber(String text, Class<T> targetClass) {
    Assert.notNull(text, "Text must not be null");
    Assert.notNull(targetClass, "Target class must not be null");
    String trimmed = StringUtils.trimAllWhitespace(text);
    
    //类型转换
    if (Byte.class == targetClass) {
        return isHexNumber(trimmed) ? Byte.decode(trimmed) : Byte.valueOf(trimmed);
    } else if (Short.class == targetClass) {
        return isHexNumber(trimmed) ? Short.decode(trimmed) : Short.valueOf(trimmed);
    } else if (Integer.class == targetClass) {
        return isHexNumber(trimmed) ? Integer.decode(trimmed) : Integer.valueOf(trimmed);
    } else if (Long.class == targetClass) {
        return isHexNumber(trimmed) ? Long.decode(trimmed) : Long.valueOf(trimmed);
    } else if (BigInteger.class == targetClass) {
        return isHexNumber(trimmed) ? decodeBigInteger(trimmed) : new BigInteger(trimmed);
    } else if (Float.class == targetClass) {
        return Float.valueOf(trimmed);
    } else if (Double.class == targetClass) {
        return Double.valueOf(trimmed);
    } else if (BigDecimal.class != targetClass && Number.class != targetClass) {
        throw new IllegalArgumentException("Cannot convert String [" + text + "] to target class [" + targetClass.getName() + "]");
    } else {
        return new BigDecimal(trimmed);
    }
}
```



#### (3) WebDataBinder补充

​	web数据绑定器，将webRequest中的数据，绑定到指定的JavaBean中



创建的WebDataBinder：

![1670664920242](E:\SpringBoot笔记\image\1670664920242.png)



**WebDataBinder 利用它里面的 Converters 将请求数据转成指定的数据类型。再次封装到JavaBean中**

**在过程当中，用到GenericConversionService：在设置每一个值的时候，找它里面的所有converter那个可以将这个数据类型（request带来参数的字符串）转换到指定的类型**



扩展：未来我们也可以在WebDataBinder中放自己的Converter

**public static final class StringToNumber<T extends Number> implements Converter<String, T>**



### 5. 自定义Converter原理

未来我们可以给WebDataBinder里面放自己的Converter；



修改

```html
<form action="/saveuser" method="post">
    
    姓名： <input name="userName" value="zhangsan"/> <br/>
    年龄： <input name="age" value="18"/> <br/>
    生日： <input name="birth" value="2019/12/10"/> <br/>
    
    <!-- 宠物姓名：<input name="pet.name" value="阿猫"/><br/> -->
    <!-- 宠物年龄：<input name="pet.age" value="5"/> -->
    宠物： <input name="pet" value="啊猫,3"/>
    
    <input type="submit" value="保存"/>
</form>

```

下面演示将字符串 "啊猫,3" 转换成 Pet 对象。

```java
    //1、WebMvcConfigurer定制化SpringMVC的功能
    @Bean
    public WebMvcConfigurer webMvcConfigurer(){
        return new WebMvcConfigurer() {

            //重写 addFormatters(), 这个方法可以添加 converter类型转换器 或者一些 格式化器(eg:时间格式化器)
            @Override
            public void addFormatters(FormatterRegistry registry) {
                
                //添加一个converter类型转换器 （使用内部类 创建需要的转换器）
                registry.addConverter(new Converter<String, Pet>() {
					
                    @Override
                    public Pet convert(String source) {
                        //source为页面提交过来的值（ 啊猫,3 ）
                        if(!StringUtils.isEmpty(source)){
                            //封装成一个pat对象返回
                            Pet pet = new Pet();
                            String[] split = source.split(",");
                            pet.setName(split[0]);
                            pet.setAge(Integer.parseInt(split[1]));
                            return pet;
                        }
                        return null;
                    }
                });
                
            }
        };
    }
```



## 九、响应处理-【源码分析】





![在这里插入图片描述](image/20210205010403920.jpg)



==本章节对应的代码在 boot-05-web-01==



### 1. 响应数据原理(全过程)



**案例演示：**

http://localhost:8888/test/person

假设给前端自动返回json数据，需要引入相关的依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- web场景自动引入了json场景 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-json</artifactId>
    <version>2.3.4.RELEASE</version>
    <scope>compile</scope>
</dependency>
```

控制层代码如下：

```java
@Controller
public class ResponseTestController {
    
	@ResponseBody  //利用返回值处理器里面的消息转换器进行处理
    @GetMapping(value = "/test/person")
    public Person getPerson(){
        Person person = new Person();
        person.setAge(28);
        person.setBirth(new Date());
        person.setUserName("zhangsan");
        return person;
    }

}
```

回顾一下上一章讲解 请求处理的时候，会初始化所有的返回值处理器，设置到目标方法类中（响应数据时需要使用）

```java
============================================ RequestMappingHandlerAdapter ==========================================

if (this.returnValueHandlers != null) {
	invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
}
```



我们直接跳过请求处理部分，处理返回值开始分析

```java
============================================ ServletInvocableHandlerMethod ======================================
public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
    //请求处理，执行目标方法
    Object returnValue = this.invokeForRequest(webRequest, mavContainer, providedArgs);
    //设置响应状态
    this.setResponseStatus(webRequest);
    //如果目标方法的返回值为空，就直接返回
    if (returnValue == null) {
        if (this.isRequestNotModified(webRequest) || this.getResponseStatus() != null || mavContainer.isRequestHandled()) {
            this.disableContentCachingIfNecessary(webRequest);
            mavContainer.setRequestHandled(true);
            return;
        }
    } else if (StringUtils.hasText(this.getResponseStatusReason())) {
        mavContainer.setRequestHandled(true);
        return;
    }

    mavContainer.setRequestHandled(false);
    Assert.state(this.returnValueHandlers != null, "No return value handlers");

    try {
        //处理返回值 <-- 从这里开始分析
        this.returnValueHandlers.handleReturnValue(returnValue, this.getReturnValueType(returnValue), mavContainer, webRequest);
    } catch (Exception var6) {
        if (this.logger.isTraceEnabled()) {
            this.logger.trace(this.formatErrorForReturnValue(returnValue), var6);
        }

        throw var6;
    }
}

==================================== HandlerMethodReturnValueHandlerComposite ======================================
public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
    
    //(1) 选择返回值处理器
    HandlerMethodReturnValueHandler handler = this.selectHandler(returnValue, returnType);
    if (handler == null) {
        throw new IllegalArgumentException("Unknown return value type: " + returnType.getParameterType().getName());
    } else {
        //(2)返回值处理器 处理响应数据
        handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
    }
}
```

#### (1) 选择返回值处理器

```java
==================================== HandlerMethodReturnValueHandlerComposite ======================================
@Nullable
private HandlerMethodReturnValueHandler selectHandler(@Nullable Object value, MethodParameter returnType) {
    //(1.1)判断是不是一个异步返回值
    boolean isAsyncValue = this.isAsyncReturnValue(value, returnType);
    Iterator var4 = this.returnValueHandlers.iterator();

    //遍历所有返回值解析器
    HandlerMethodReturnValueHandler handler;
    do {
        do {
            if (!var4.hasNext()) {
                return null;
            }

            handler = (HandlerMethodReturnValueHandler)var4.next();
            //该返回值不是一个异步请求，且该返回值解析器不是 AsyncHandlerMethodReturnValueHandler类型
        } while(isAsyncValue && !(handler instanceof AsyncHandlerMethodReturnValueHandler));
        //(1.2)判断该参数解析器是否支持解析该参数 <--
    } while(!handler.supportsReturnType(returnType));

    return handler;
}
```

(1.1)判断是不是一个异步返回值

```java
//(1.1)判断是不是一个异步返回值 
private boolean isAsyncReturnValue(@Nullable Object value, MethodParameter returnType) {
    Iterator var3 = this.returnValueHandlers.iterator();

    HandlerMethodReturnValueHandler handler;
    
    //do...while循环，遍历所有返回值处理器
    do {
        if (!var3.hasNext()) {
            //遍历完所有的返回值处理器，判断不是一个异步
            return false;
        }

        handler = (HandlerMethodReturnValueHandler)var3.next();
        //编历到 类型为 AsyncHandlerMethodReturnValueHandler的返回值处理器时
        //使用这个返回值处理器，调用 isAsyncReturnValue() 来判断返回值，是不是一个异步返回值
    } while(!(handler instanceof AsyncHandlerMethodReturnValueHandler) ||
            !((AsyncHandlerMethodReturnValueHandler)handler).isAsyncReturnValue(value, returnType));
    //判断结果为是，返回true
    return true;
}
```

(1.2)判断该参数解析器是否支持解析该参数

```java
//例题中标注了@ResponseBody，所以使用的是 RequestResponseBodyMethodProcessor返回值处理器
========================================== RequestResponseBodyMethodProcessor ====================================

public boolean supportsReturnType(MethodParameter returnType) {
    return AnnotatedElementUtils.hasAnnotation(returnType.getContainingClass(), ResponseBody.class) || 
        returnType.hasMethodAnnotation(ResponseBody.class);
}
```



#### (2) 处理响应数据

```java
========================================== RequestResponseBodyMethodProcessor  ====================================
// handler.handleReturnValue()
public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {
    mavContainer.setRequestHandled(true);
    //将原生webRequest，封装到 inputMessage 和 outputMessage 中 
    ServletServerHttpRequest inputMessage = this.createInputMessage(webRequest);
    ServletServerHttpResponse outputMessage = this.createOutputMessage(webRequest);
    //使用 消息转换器 进行写出操作 <--
    this.writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);
}


//使用 消息转换器 进行写出操作 <--
protected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {
    Object body;
    Class valueType;
    Object targetType;
    
    //判断返回值是不是字符串类型 （很明显Person对象不是字符串类型）
    if (value instanceof CharSequence) {
        body = value.toString();
        valueType = String.class;
        targetType = String.class;
    } else { //否则执行这里
        //获取值
        body = value;
        //获取值的类型信息
        valueType = this.getReturnValueType(value, returnType);
        //获取目标类型
        targetType = GenericTypeResolver.resolveType(this.getGenericType(returnType), returnType.getContainingClass());
    }

    //判断是不是资源类型 （比如说一些 InputStreamResource流类型数据， 很明显Person也不是这种类型）
    if (this.isResourceType(value, returnType)) {
        outputMessage.getHeaders().set("Accept-Ranges", "bytes");
        if (value != null && inputMessage.getHeaders().getFirst("Range") != null && outputMessage.getServletResponse().getStatus() == 200) {
            Resource resource = (Resource)value;

            try {
                List<HttpRange> httpRanges = inputMessage.getHeaders().getRange();
                outputMessage.getServletResponse().setStatus(HttpStatus.PARTIAL_CONTENT.value());
                body = HttpRange.toResourceRegions(httpRanges, resource);
                valueType = body.getClass();
                targetType = RESOURCE_REGION_LIST_TYPE;
            } catch (IllegalArgumentException var19) {
                outputMessage.getHeaders().set("Content-Range", "bytes */" + resource.contentLength());
                outputMessage.getServletResponse().setStatus(HttpStatus.REQUESTED_RANGE_NOT_SATISFIABLE.value());
            }
        }
    }

 ------------------------ 内容协商 部分 -----------------------------------------------------
    // 媒体类型 【涉及到内容协商（浏览器默认会以请求头(参数Accept)的方式告诉服务器他能接受什么样的内容类型）】
    // Accept（eg: ）
    MediaType selectedMediaType = null;
    //判断当前响应头中是否已经有确定的媒体类型
    MediaType contentType = outputMessage.getHeaders().getContentType();
    boolean isContentTypePreset = contentType != null && contentType.isConcrete();
    //(a) 请求头中有：将该类型作为 服务器响应的内容类型
    if (isContentTypePreset) {
        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Found 'Content-Type:" + contentType + "' in response");
        }
		//有就直接使用（将该类型作为 服务器响应的内容类型）
        selectedMediaType = contentType;
    
    //(b) 就匹配 浏览器可以接收的内容类型 和 服务器可以响应的内容类型 ，选择一个匹配的内容类型 作为服务器最终需响应的内容类型
    } else {
        //获取原生的request
        HttpServletRequest request = inputMessage.getServletRequest();
        //1.获取客户端（PostMan、浏览器）支持接收的内容类型（获取客户端Accept请求头字段)【内容协商原理补充的时候详细讲解】
        List<MediaType> acceptableTypes = this.getAcceptableMediaTypes(request);
        //2. 获取当前服务器可以响应的内容类型 【内容协商原理补充的时候详细讲解】
        List<MediaType> producibleTypes = this.getProducibleMediaTypes(request, valueType, (Type)targetType);
        if (body != null && producibleTypes.isEmpty()) {
            throw new HttpMessageNotWritableException("No converter found for return value of type: " + valueType);
        }

        List<MediaType> mediaTypesToUse = new ArrayList();
        Iterator var15 = acceptableTypes.iterator();
        MediaType mediaType;
        //3. 遍历 acceptableTypes 和 producibleTypes，选出相匹配的媒体类型 
        while(var15.hasNext()) {
            mediaType = (MediaType)var15.next();
            Iterator var17 = producibleTypes.iterator();
            
            while(var17.hasNext()) {
                MediaType producibleType = (MediaType)var17.next();
                //如果服务器响应的和浏览器接收的 内容类型相同
                if (mediaType.isCompatibleWith(producibleType)) {
                    //将该MediaType添加到集合中（这个集合里面存放的就都是 我们可以写出的所有内容类型的数据）
                    mediaTypesToUse.add(this.getMostSpecificMediaType(mediaType, producibleType));
                }
            }
        }

        if (mediaTypesToUse.isEmpty()) {
            if (body != null) {
                throw new HttpMediaTypeNotAcceptableException(producibleTypes);
            }

            if (this.logger.isDebugEnabled()) {
                this.logger.debug("No match for " + acceptableTypes + ", supported: " + producibleTypes);
            }

            return;
        }

        //排序（按照权重和详细程度(有没有编码等）进行的）
        MediaType.sortBySpecificityAndQuality(mediaTypesToUse);
  
        //选择一个MediaType【上面已经按权重匹配了，所以选择的肯定是 权重高的】
        var15 = mediaTypesToUse.iterator();
        while(var15.hasNext()) {
            mediaType = (MediaType)var15.next();
            if (mediaType.isConcrete()) {
                selectedMediaType = mediaType;
                break;
            }

            if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) {
                selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;
                break;
            }
        }

        if (this.logger.isDebugEnabled()) {
            this.logger.debug("Using '" + selectedMediaType + "', given " + acceptableTypes + " and supported " 
                              + producibleTypes);
        }
    }

    //======到这里，就已经确定了 服务器需要响应的一个内容类型 （本例题是 Json格式内容类型）===========
    ------------------------------------ 选择消息转换器 部分 -------------------------------------------------------
    
    //消息转换器 HttpMessageConverter（所有具体消息转换器的 最高父接口）,
    HttpMessageConverter converter;
    //消息转换器 GenericHttpMessageConverter（所有具体消息转换器的父接口，HttpMessageConverter的子接口）
    GenericHttpMessageConverter genericConverter;
    
    label159: {
        if (selectedMediaType != null) {
            selectedMediaType = selectedMediaType.removeQualityValue();
            //遍历所有的消息转换器，看谁能处理 这种内容类型
            Iterator var22 = this.messageConverters.iterator();
            while(var22.hasNext()) {
                
                //将该 转换器放入 HttpMessageConverter
                converter = (HttpMessageConverter)var22.next();
                //如果该转换器 为GenericHttpMessageConverter类型（默认的信息转换器都是它的实现类）也放入 GenericHttpMessageConverter
                genericConverter = converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter)converter : null;
                
                //(a) 调用消息转换器的canWrite(clazz,mediaType)：
                //    判断该 converter能不能支持，将 clazz 以mediaType类型方式 写出去 (mediaType类型方式 在上一步已经确定了)
                if (genericConverter != null) {
                    if (((GenericHttpMessageConverter)converter).canWrite((Type)targetType, valueType, selectedMediaType)) {
                        //退出 label159
                        break label159;
                    }
                } else if (converter.canWrite(valueType, selectedMediaType)) {
                    //退出 label159
                    break label159;
                }
            }
        }

        if (body != null) {
            Set<MediaType> producibleMediaTypes = (Set)inputMessage.getServletRequest().getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);
            if (!isContentTypePreset && CollectionUtils.isEmpty(producibleMediaTypes)) {
                throw new HttpMediaTypeNotAcceptableException(this.allSupportedMediaTypes);
            }

            throw new HttpMessageNotWritableException("No converter for [" + valueType + "] with preset Content-Type '" + contentType + "'");
        }

        return;
    }
    
    //======到这一步已经得到了 使用的消息转换器（本例题是 以Json方式写出去 使用 MappingJackson2HttpMessageConverter ）===================
    ------------------------------------------- 真正开始响应数据 -----------------------------------------------------------   
    
    //获取将需要响应的内容消息
    body = this.getAdvice().beforeBodyWrite(body, returnType, selectedMediaType, converter.getClass(), inputMessage, outputMessage);
    if (body != null) {
        LogFormatUtils.traceDebug(this.logger, (traceOn) -> {
            return "Writing [" + LogFormatUtils.formatValue(body, !traceOn) + "]";
        });
        //添加一些头信息
        this.addContentDispositionHeader(inputMessage, outputMessage);
        //(b) 调用消息转换器的 write()，将 clazz，以 mediaType类型方式 写出去 （eg：将Person以json类型方式写出去）
        if (genericConverter != null) { 
            genericConverter.write(body, (Type)targetType, selectedMediaType, outputMessage);
        } else {
            converter.write(body, selectedMediaType, outputMessage);
        }
    } else if (this.logger.isDebugEnabled()) {
        this.logger.debug("Nothing to write: null body");
    }

}
```

不同的消息转换器 有着不同的写原理（下面继续分析以本例题中 MappingJackson2HttpMessageConverter消息转换器为例 （Json格式） ）

```java
============================ AbstractGenericHttpMessageConverter ================================

//(b)调用消息转换器的 write()，将 clazz，以 mediaType类型方式（json） 写出去 
public final void write(T t, @Nullable Type type, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
    //获取默认的响应头
    HttpHeaders headers = outputMessage.getHeaders();
    //往响应头中添加 Content-Type响应内容类型 （Content-Type内容的值为application/json）
    this.addDefaultHeaders(headers, t, contentType);
    
    if (outputMessage instanceof StreamingHttpOutputMessage) {
        StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage)outputMessage;
        streamingOutputMessage.setBody((outputStream) -> {
            this.writeInternal(t, type, new HttpOutputMessage() {
                public OutputStream getBody() {
                    return outputStream;
                }

                public HttpHeaders getHeaders() {
                    return headers;
                }
            });
        });
    } else {
        //MappingJackson2HttpMessageConverter信息转换器 调用writeInternal()  将返回值写到响应里 <--
        this.writeInternal(t, type, outputMessage);
        outputMessage.getBody().flush();
    }

}

============================================ AbstractJackson2HttpMessageConverter =================================================

//  this.writeInternal(t, type, outputMessage);
protected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
    //获取媒体类型（application/json）
    MediaType contentType = outputMessage.getHeaders().getContentType();
    ///获取编号格式（UTF-8）
    JsonEncoding encoding = this.getJsonEncoding(contentType);
    //获取生成器
    JsonGenerator generator = this.objectMapper.getFactory().createGenerator(outputMessage.getBody(), encoding);

    try {
        this.writePrefix(generator, object);
        Object value = object;
        Class<?> serializationView = null;
        FilterProvider filters = null;
        JavaType javaType = null;
        if (object instanceof MappingJacksonValue) {
            MappingJacksonValue container = (MappingJacksonValue)object;
            value = container.getValue();
            serializationView = container.getSerializationView();
            filters = container.getFilters();
        }

        if (type != null && TypeUtils.isAssignable(type, value.getClass())) {
            javaType = this.getJavaType(type, (Class)null);
        }

        //获取Writer 
        ObjectWriter objectWriter = serializationView != null ? this.objectMapper.writerWithView(serializationView) : this.objectMapper.writer();
        if (filters != null) {
            objectWriter = objectWriter.with(filters);
        }

        if (javaType != null && javaType.isContainerType()) {
            objectWriter = objectWriter.forType(javaType);
        }

        SerializationConfig config = objectWriter.getConfig();
        if (contentType != null && contentType.isCompatibleWith(MediaType.TEXT_EVENT_STREAM) && config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {
            objectWriter = objectWriter.with(this.ssePrettyPrinter);
        }

        //调用writeValue(),将返回值以json格式写到响应中，outputMessage中就存放了响应信息
        objectWriter.writeValue(generator, value);
        this.writeSuffix(generator, object);
        generator.flush();
    } catch (InvalidDefinitionException var13) {
        throw new HttpMessageConversionException("Type definition error: " + var13.getType(), var13);
    } catch (JsonProcessingException var14) {
        throw new HttpMessageNotWritableException("Could not write JSON: " + var14.getOriginalMessage(), var14);
    }
}
```

(Ⅰ) 利用指定的 MessageConverters消息转换器 进行处理 将数据写为json

#### 总结整个响应数据过程

返回值处理器 ReturnValueHandler 原理：

1. 选择返回值处理器

	1）遍历所有返回值处理器，判断是否支持出来 这种类型返回值  

	2）发现 RequestResponseBodyMethodProcessor返回值处理器 可以处理返回值标了 @ResponseBody注解的。

2. 处理响应数据

	1）该返回值处理器调用  handleReturnValue()进行处理

	​    首先判断返回值是不是字符串，是不是资源类型，不是继续

	​	(1) 内容协商

	​		1.1 获取确定的媒体类型

	​			判断当前响应头中是否已经有确定的媒体类型，是直接作为响应的媒体类型，不是继续

	​			a. 获取客户端支持接收的媒体内容类型（ 获取所有支持处理这种返回值(Person)的消息转换器，集合这些转换器持转换的媒体类型 ）

	​			b. 获取客户端要求响应的媒体内容类型（ 获取内容协商管理器中的 内容协商策略(默认是基于请求头的策略)，使用这些策略获取 																			                客户端要求转换的媒体类型）

	​			c. 两者相互匹配，得到一个确定响应的媒体类型（json）

	​		1.2 获取确定的消息转换器

	​			a.遍历所有的 HttpMessageConverter消息转换器，看那个可以 将返回值转为确定的媒体类型，作为确定的消息转换器

	​	(2) 真正开始响应数据

	​		 a.使用消息转换器，将响应数据以 确定的媒体内容类型 写入响应中

	

	

### 2. HTTPMessageConverter补充



HTTPMessageConverter接口

​	接口里面有5个方法:

```java
/**
 * Strategy interface for converting from and to HTTP requests and responses.
 * 
 */
public interface HttpMessageConverter<T> {

	/**
	 * Indicates whether the given class can be read by this converter.
	 *  
	 *  该消息转换器 是否支持 将clazz，以mediaType媒体类型方式 读取进来
	 *  eg：是否支持 将person对象 以json字符串方式 读取进来 （Json --> Person）
	 */
	boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);

	/**
	 * Indicates whether the given class can be written by this converter.
	 *
	 *  该消息转换器 是否支持 将clazz，以mediaType媒体类型方式 写出去
	 *  eg：是否支持 将person对象 以json字符串方式 写出去 （Person --> Json）
	 */
	boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);

	/**
	 * Return the list of {@link MediaType} objects supported by this converter.
	 *
	 *
	 */
	List<MediaType> getSupportedMediaTypes();

	/**
	 * Read an object of the given type from the given input message, and returns it.
	 */
	T read(Class<? extends T> clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException;

	/**
	 * Write an given object to the given output message.
	 */
	void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)
			throws IOException, HttpMessageNotWritableException;

}

```

HttpMessageConverter: 看是否支持将 此 Class类型的对象，转为 MediaType类型的数据。



如：Person对象转为JSON，或者 JSON转为 Person，这将用到 **MappingJackson2HttpMessageConverter**

![在这里插入图片描述](image/20210205010509984.png)

```java
public class MappingJackson2HttpMessageConverter extends AbstractJackson2HttpMessageConverter {
    @Nullable
    private String jsonPrefix;

    public MappingJackson2HttpMessageConverter() {
        this(Jackson2ObjectMapperBuilder.json().build());
    }

    public MappingJackson2HttpMessageConverter(ObjectMapper objectMapper) {
        super(objectMapper, new MediaType[]{MediaType.APPLICATION_JSON, new MediaType("application", "*+json")});
    }

    public void setJsonPrefix(String jsonPrefix) {
        this.jsonPrefix = jsonPrefix;
    }

    public void setPrefixJson(boolean prefixJson) {
        this.jsonPrefix = prefixJson ? ")]}', " : null;
    }

    protected void writePrefix(JsonGenerator generator, Object object) throws IOException {
        if (this.jsonPrefix != null) {
            generator.writeRaw(this.jsonPrefix);
        }

    }
}

```



如：Person对象转为XML，或者 XML转为 Person，这将用到 **MappingJackson2XmlHttpMessageConverter**

![1671007704049](E:\SpringBoot笔记\image\1671007704049.png)

```java
public class MappingJackson2XmlHttpMessageConverter extends AbstractJackson2HttpMessageConverter {
    public MappingJackson2XmlHttpMessageConverter() {
        this(Jackson2ObjectMapperBuilder.xml().build());
    }

    public MappingJackson2XmlHttpMessageConverter(ObjectMapper objectMapper) {
        super(objectMapper, new MediaType[]{new MediaType("application", "xml", StandardCharsets.UTF_8), new MediaType("text", "xml", StandardCharsets.UTF_8), new MediaType("application", "*+xml", StandardCharsets.UTF_8)});
        Assert.isInstanceOf(XmlMapper.class, objectMapper, "XmlMapper required");
    }

    public void setObjectMapper(ObjectMapper objectMapper) {
        Assert.isInstanceOf(XmlMapper.class, objectMapper, "XmlMapper required");
        super.setObjectMapper(objectMapper);
    }
}
```





#### (1) HttpMessageConverters的初始化

DispatcherServlet 的初始化时会调用 initHandlerAdapters(ApplicationContext context)

```java
public class DispatcherServlet extends FrameworkServlet {
    
    ...
    
	private void initHandlerAdapters(ApplicationContext context) {
		this.handlerAdapters = null;

		if (this.detectAllHandlerAdapters) {
			// Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.
			Map<String, HandlerAdapter> matchingBeans =
					BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);
			if (!matchingBeans.isEmpty()) {
				this.handlerAdapters = new ArrayList<>(matchingBeans.values());
				// We keep HandlerAdapters in sorted order.
				AnnotationAwareOrderComparator.sort(this.handlerAdapters);
			}
		}
      ...
```

上述代码会加载 ApplicationContext 的所有 HandlerAdapter，用来处理 @RequestMapping 的 RequestMappingHandlerAdapter 实现 HandlerAdapter接口，RequestMappingHandlerAdapter也被实例化。

```java
public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean {
    
    ...

    private List<HttpMessageConverter<?>> messageConverters;
    
    ...
    
	public RequestMappingHandlerAdapter() {
		this.messageConverters = new ArrayList<>(4);
		this.messageConverters.add(new ByteArrayHttpMessageConverter());
		this.messageConverters.add(new StringHttpMessageConverter());
		if (!shouldIgnoreXml) {
			try {
				this.messageConverters.add(new SourceHttpMessageConverter<>());
			}
			catch (Error err) {
				// Ignore when no TransformerFactory implementation is available
			}
		}
		//添加所有的 消息转换器
		this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());
	}
```

在构造器中看到**一堆** HttpMessageConverter。接着，重点查看 AllEncompassingFormHttpMessageConverter类：

```java
public class AllEncompassingFormHttpMessageConverter extends FormHttpMessageConverter {

	/**
	 * Boolean flag controlled by a {@code spring.xml.ignore} system property that instructs Spring to
	 * ignore XML, i.e. to not initialize the XML-related infrastructure.
	 * <p>The default is "false".
	 */
	private static final boolean shouldIgnoreXml = SpringProperties.getFlag("spring.xml.ignore");

	private static final boolean jaxb2Present;

	private static final boolean jackson2Present;

	private static final boolean jackson2XmlPresent;

	private static final boolean jackson2SmilePresent;

	private static final boolean gsonPresent;

	private static final boolean jsonbPresent;

	private static final boolean kotlinSerializationJsonPresent;

	static {
		ClassLoader classLoader = AllEncompassingFormHttpMessageConverter.class.getClassLoader();
		jaxb2Present = ClassUtils.isPresent("javax.xml.bind.Binder", classLoader);
		jackson2Present = ClassUtils.isPresent("com.fasterxml.jackson.databind.ObjectMapper", classLoader) &&
						ClassUtils.isPresent("com.fasterxml.jackson.core.JsonGenerator", classLoader);
		jackson2XmlPresent = ClassUtils.isPresent("com.fasterxml.jackson.dataformat.xml.XmlMapper", classLoader);
		jackson2SmilePresent = ClassUtils.isPresent("com.fasterxml.jackson.dataformat.smile.SmileFactory", classLoader);
		gsonPresent = ClassUtils.isPresent("com.google.gson.Gson", classLoader);
		jsonbPresent = ClassUtils.isPresent("javax.json.bind.Jsonb", classLoader);
		kotlinSerializationJsonPresent = ClassUtils.isPresent("kotlinx.serialization.json.Json", classLoader);
	}


	public AllEncompassingFormHttpMessageConverter() {
		if (!shouldIgnoreXml) {
			try {
				addPartConverter(new SourceHttpMessageConverter<>());
			}
			catch (Error err) {
				// Ignore when no TransformerFactory implementation is available
			}

			if (jaxb2Present && !jackson2XmlPresent) {
				addPartConverter(new Jaxb2RootElementHttpMessageConverter());
			}
		}

		if (jackson2Present) {
			addPartConverter(new MappingJackson2HttpMessageConverter());//<----重点看这里
		}
		else if (gsonPresent) {
			addPartConverter(new GsonHttpMessageConverter());
		}
		else if (jsonbPresent) {
			addPartConverter(new JsonbHttpMessageConverter());
		}
		else if (kotlinSerializationJsonPresent) {
			addPartConverter(new KotlinSerializationJsonHttpMessageConverter());
		}

		if (jackson2XmlPresent && !shouldIgnoreXml) {
			addPartConverter(new MappingJackson2XmlHttpMessageConverter());
		}

		if (jackson2SmilePresent) {
			addPartConverter(new MappingJackson2SmileHttpMessageConverter());
		}
	}

}

public class FormHttpMessageConverter implements HttpMessageConverter<MultiValueMap<String, ?>> {
    
    ...
        
    private List<HttpMessageConverter<?>> partConverters = new ArrayList<>();
    
    ...
        
    public void addPartConverter(HttpMessageConverter<?> partConverter) {
		Assert.notNull(partConverter, "'partConverter' must not be null");
		this.partConverters.add(partConverter);
	}
    
    ...
}

```

在 AllEncompassingFormHttpMessageConverter 类构造器看到 MappingJackson2HttpMessageConverter类的实例化，AllEncompassingFor mHttpMessageConverter **包含** MappingJackson2HttpMessageConverter。



ReturnValueHandler 是怎么与 MappingJackson2HttpMessageConverter关联起来

#### (2) ReturnValueHandler与MappingJackson2HttpMessageConverter关联

再次回顾 RequestMappingHandlerAdapter

```java
public class RequestMappingHandlerAdapter extends AbstractHandlerMethodAdapter
		implements BeanFactoryAware, InitializingBean {
    
    ...
    @Nullable
	private HandlerMethodReturnValueHandlerComposite returnValueHandlers;//我们关注的returnValueHandlers
    
   	
    @Override
	@Nullable//本方法在AbstractHandlerMethodAdapter
	public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {

		return handleInternal(request, response, (HandlerMethod) handler);
	}
        
    @Override
	protected ModelAndView handleInternal(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {
		ModelAndView mav;
        ...
        mav = invokeHandlerMethod(request, response, handlerMethod);
        ...
		return mav;
	}
    
    @Nullable
	protected ModelAndView invokeHandlerMethod(HttpServletRequest request,
			HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {

		ServletWebRequest webRequest = new ServletWebRequest(request, response);
		try {
			WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);
			ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);

			ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);
			if (this.argumentResolvers != null) {
				invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);
			}
			if (this.returnValueHandlers != null) {//<---我们关注的returnValueHandlers
				invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);
			}
            
            ...
            
			invocableMethod.invokeAndHandle(webRequest, mavContainer);
			if (asyncManager.isConcurrentHandlingStarted()) {
				return null;
			}

			return getModelAndView(mavContainer, modelFactory, webRequest);
		}
		finally {
			webRequest.requestCompleted();
		}
	}
    
   @Override
	public void afterPropertiesSet() {
		// Do this first, it may add ResponseBody advice beans
		
        ...
        
		if (this.returnValueHandlers == null) {//赋值returnValueHandlers
			List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();
			this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);
		}
	}
    
    private List<HandlerMethodReturnValueHandler> getDefaultReturnValueHandlers() {
		List<HandlerMethodReturnValueHandler> handlers = new ArrayList<>(20);

		...
		// Annotation-based return value types
        //这里就是 ReturnValueHandler与 MappingJackson2HttpMessageConverter关联 的关键点
		handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(),//<---MessageConverters也就传参传进来的
				this.contentNegotiationManager, this.requestResponseBodyAdvice));//
        ...

		return handlers;
	}
    
    //------
    
    public List<HttpMessageConverter<?>> getMessageConverters() {
		return this.messageConverters;
	}
    
    //RequestMappingHandlerAdapter构造器已初始化部分messageConverters
   	public RequestMappingHandlerAdapter() {
		this.messageConverters = new ArrayList<>(4);
		this.messageConverters.add(new ByteArrayHttpMessageConverter());
		this.messageConverters.add(new StringHttpMessageConverter());
		if (!shouldIgnoreXml) {
			try {
				this.messageConverters.add(new SourceHttpMessageConverter<>());
			}
			catch (Error err) {
				// Ignore when no TransformerFactory implementation is available
			}
		}
		this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());
	}

    ...
              
}
```

应用中 WebMvcAutoConfiguration （底层是 WebMvcConfigurationSupport实现）传入更多 messageConverters ，其中就包含MappingJackson2HttpMessageConverter。

### 3. 内容协商原理补充

概念：根据客户端接收能力不同，返回不同媒体类型的数据。



引入XML依赖：

```xml
 <dependency>
     <groupId>com.fasterxml.jackson.dataformat</groupId>
     <artifactId>jackson-dataformat-xml</artifactId>
</dependency>
```

可用Postman软件分别测试返回json和xml：只需要改变请求头中Accept字段（application/json、application/xml）。

Http协议中规定的，Accept字段告诉服务器本客户端可以接收的数据类型。



**本节研究 内容协商原理 使用的例题为**：服务器端执行目标方法返回值类型为Person对象，客户端声明使用 application/xml接收



**内容协商原理**：

1. 判断当前响应头中是否已经有确定的媒体类型 MediaType。

2. 获取客户端（PostMan、浏览器）支持接收的内容类型（获取客户端Accept请求头字段application/xml）（这一步在下一节有详细介绍）
   
   contentNegotiationManager(内容协商管理器) 默认使用 HeaderContentNegotiationStrategy(基于请求头的内容协商策略) 来确定客户端可以接收的内容类型 
   
3. 获取服务器端可以产出的内容类型

	- 遍历循环所有当前系统的 MessageConverter消息转换器，看谁支持操作这个对象（Person）

	- 找到支持操作这个对象（Person）的converter，将这些converter支持的所有媒体内容类型统计出来。

4. 上面两步得到的消息有：客户端需要【application/xml】，服务端有【10种MediaType】 支持处理Person对象。

5. 进行内容协商的最佳匹配媒体类型

6. 获取支持 将对象(Person)转为 最佳匹配媒体类型(application/xml) 的converter消息转换器。调用它进行转化 。



```java

//RequestResponseBodyMethodProcessor继承这类
public abstract class AbstractMessageConverterMethodProcessor extends AbstractMessageConverterMethodArgumentResolver
		implements HandlerMethodReturnValueHandler {

    ...
    
    //跟第一节的代码一致
    protected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType,ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {

		Object body;
        Class<?> valueType;
        Type targetType;

		if (value instanceof CharSequence) {
        	body = value.toString();
            valueType = String.class;
            targetType = String.class;
      	}
        else {
        	body = value;
            valueType = getReturnValueType(body, returnType);
            targetType = GenericTypeResolver.resolveType(getGenericType(returnType), returnType.getContainingClass());
     	}

		...

      	//本节重点 <--
     	//内容协商（浏览器默认会以请求头(参数Accept)的方式告诉服务器他能接受什么样的内容类型）
        MediaType selectedMediaType = null;
        //1. 判断当前响应头中是否已经有确定的媒体类型 MediaType。
        MediaType contentType = outputMessage.getHeaders().getContentType();
        boolean isContentTypePreset = contentType != null && contentType.isConcrete();
        if (isContentTypePreset) {
        	if (logger.isDebugEnabled()) {
        		logger.debug("Found 'Content-Type:" + contentType + "' in response");
        	}
        	//有就使用之前确定的媒体类型
        	selectedMediaType = contentType;
        //2. 没有就获取：
        } else {
        	HttpServletRequest request = inputMessage.getServletRequest();
            //(2.1) 获取客户端（PostMan、浏览器等）支持接收的内容类型（默认获取客户端Accept请求头字段)
            List<MediaType> acceptableTypes = getAcceptableMediaTypes(request);
            //(2.2) 获取服务器服务器端，可以产出的内容类型数据（根据服务器自身的能力，决定服务器能生产出什么样内容类型的数据）
            List<MediaType> producibleTypes = getProducibleMediaTypes(request, valueType, targetType);

			if (body != null && producibleTypes.isEmpty()) {
            	throw new HttpMessageNotWritableException(
                "No converter found for return value of type: " + valueType);
            }
            //(2.3) 遍历 acceptableTypes 和 producibleTypes，选出相匹配的媒体类型 
            List<MediaType> mediaTypesToUse = new ArrayList<>();
            for (MediaType requestedType : acceptableTypes) {
             	for (MediaType producibleType : producibleTypes) {
                	if (requestedType.isCompatibleWith(producibleType)) {
                    	mediaTypesToUse.add(getMostSpecificMediaType(requestedType, producibleType));
                     }
                }
           	}
           	// 没有相匹配的就抛出异常
            if (mediaTypesToUse.isEmpty()) {
             	if (body != null) {
                	throw new HttpMediaTypeNotAcceptableException(producibleTypes);
              	}
                if (logger.isDebugEnabled()) {
                	logger.debug("No match for " + acceptableTypes + ", supported: " + producibleTypes);
                }
              	 	return;
           	}

			//排序（按照权重和详细程度(有没有编码等）进行的）
			MediaType.sortBySpecificityAndQuality(mediaTypesToUse);

            //选择一个MediaType【上面已经按权重匹配了，所以选择的肯定是 权重高的】
           	for (MediaType mediaType : mediaTypesToUse) {
            	if (mediaType.isConcrete()) {
                	selectedMediaType = mediaType;
                    break;
              	}
                else if (mediaType.isPresentIn(ALL_APPLICATION_MEDIA_TYPES)) {
                	selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;
                    break;
               	}
           	}

          	if (logger.isDebugEnabled()) {
            	logger.debug("Using '" + selectedMediaType + "', given " +
                acceptableTypes + " and supported " + producibleTypes);
            }
     	}


		//3. 获取支持的消息转换器，使用它进行数据的响应
		if (selectedMediaType != null) {
        	selectedMediaType = selectedMediaType.removeQualityValue();
           
            for (HttpMessageConverter<?> converter : this.messageConverters) {
            	GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?
                            (GenericHttpMessageConverter<?>) converter : null);

                //(3.1) 调用消息转换器的 canWrite(valueType,mediaType)：
                //   判断该 converter能不能支持，将 valueType 以mediaType类型方式 写出去 (valueType:Person、mediaType:mxl)
                if (genericConverter != null ?
                            ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :
                            converter.canWrite(valueType, selectedMediaType)) {
                     
                     //到在里面，已经获取到了那个支持的 converter 为：
                     
                    //获取最终要处理的body数据（Person对象数据）
                    body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,
                    (Class<? extends HttpMessageConverter<?>>) converter.getClass(),
                    inputMessage, outputMessage);
                    
                    if (body != null) {
                        Object theBody = body;
                        LogFormatUtils.traceDebug(logger, traceOn ->
                            "Writing [" + LogFormatUtils.formatValue(theBody, !traceOn) + "]");
                            addContentDispositionHeader(inputMessage, outputMessage);
                        
                        //(3.2)MappingJackson2XmlHttpMessageConverter消息转换器 调用的write() 开始写入
                        if (genericConverter != null) {
                            genericConverter.write(body, targetType, selectedMediaType, outputMessage);
                        } else {
                            ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);
                        }
                        
                    }else {
                        if (logger.isDebugEnabled()) {
                            logger.debug("Nothing to write: null body");
                        }
                    }
                    return;
                }
   			}
 		}	
 	...
}
```

(2.1) 获取客户端（PostMan、浏览器）支持接收的内容类型（获取客户端Accept请求头字段)

```java
================================== AbstractMessageConverterMethodProcessor ====================================

private List<MediaType> getAcceptableMediaTypes(HttpServletRequest request) throws HttpMediaTypeNotAcceptableException {
    //contentNegotiationManager内容协商管理器，用他来解析 客户端可以接收的媒体类型 <--
    return this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request));
}

===================================== ContentNegotiationManager 内容协商管理器 ====================================
//解析客户端可以接收的媒体类型 
public List<MediaType> resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException {
    
    //strategies是一个集合，里面默认只有一个 HeaderContentNegotiationStrategy基于请求头的内容协商策略,
    // 我们会使用这个 基于请求头的策略去解析 获取响应的媒体类型（解析请求头消息，获取响应的媒体类型）
    //【我们也可以添加别的策略，比如设置一个基于请求参数的内容协商策略，即可以在请求参数中设置 响应的媒体类型，下节会详细讲解】
    Iterator var2 = this.strategies.iterator();

    List mediaTypes;
    //遍历所有的内容协商策略模式（默认只有 HeaderContentNegotiationStrategy基于请求头的内容协商策略）
    do {
        if (!var2.hasNext()) {
            return MEDIA_TYPE_ALL_LIST;
        }
        ContentNegotiationStrategy strategy = (ContentNegotiationStrategy)var2.next();
        //使用 该策略模式解析方法 得到响应的媒体类型 <--
        mediaTypes = strategy.resolveMediaTypes(request);
    } while(mediaTypes.equals(MEDIA_TYPE_ALL_LIST));

    return mediaTypes;
}

=================================== HeaderContentNegotiationStrategy内容策略模式 的解析方法 =========================
public List<MediaType> resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException {
    //获取请求头中 Accept字段的值
    //（text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9）
    String[] headerValueArray = request.getHeaderValues("Accept");
    if (headerValueArray == null) {
        return MEDIA_TYPE_ALL_LIST;
    } else {
        //将数组转成集合
        List<String> headerValues = Arrays.asList(headerValueArray);

        try {
            //将字符串，以","为分隔符 分解成String集合
            List<MediaType> mediaTypes = MediaType.parseMediaTypes(headerValues);
            //按 内容和权重 排序
            MediaType.sortBySpecificityAndQuality(mediaTypes);
            return !CollectionUtils.isEmpty(mediaTypes) ? mediaTypes : MEDIA_TYPE_ALL_LIST;
        } catch (InvalidMediaTypeException var5) {
            throw new HttpMediaTypeNotAcceptableException("Could not parse 'Accept' header " + headerValues + ": " + var5.getMessage());
        }
    }
}
```

(2.2) 获取服务器服务器端，可以产出的内容类型数据

```java
=========================================== AbstractMessageConverterMethodProcessor ===========================

protected List<MediaType> getProducibleMediaTypes(HttpServletRequest request, Class<?> valueClass, @Nullable Type targetType) {
    //从请求域中获取，服务器调可以发送的媒体类型，有则直接使用
    Set<MediaType> mediaTypes = (Set)request.getAttribute(HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);
    if (!CollectionUtils.isEmpty(mediaTypes)) {
        return new ArrayList(mediaTypes);
    } else if (this.allSupportedMediaTypes.isEmpty()) {
        return Collections.singletonList(MediaType.ALL);
    } else {
        List<MediaType> result = new ArrayList();
        
        //获取所有的 massageConverter，迭代
        Iterator var6 = this.messageConverters.iterator();
        while(true) {
            while(var6.hasNext()) {
                HttpMessageConverter<?> converter = (HttpMessageConverter)var6.next();
               
                //如果该 massageConverter可以支持 该类型(Person对象) 的写操作，就添加到 可用消息转换器集合中
                if (converter instanceof GenericHttpMessageConverter && targetType != null) {
                    if (((GenericHttpMessageConverter)converter).canWrite(targetType, valueClass, (MediaType)null)) {
                        result.addAll(converter.getSupportedMediaTypes());
                    }
                } else if (converter.canWrite(valueClass, (MediaType)null)) {
                    result.addAll(converter.getSupportedMediaTypes());
                }
                
            }

            return result;
        }
    }
}
```

(3.2)调用 消息转换器的write() 开始写入

```java
==================================== AbstractGenericHttpMessageConverter ====================================

public final void write(T t, @Nullable Type type, @Nullable MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
    //获取默认响应头信息
    HttpHeaders headers = outputMessage.getHeaders();
    //向响应头 添加 Content-Type响应类型 （Content-Type的值为application/xhtml+xml）
    this.addDefaultHeaders(headers, t, contentType);
    if (outputMessage instanceof StreamingHttpOutputMessage) {
        StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage)outputMessage;
        streamingOutputMessage.setBody((outputStream) -> {
            this.writeInternal(t, type, new HttpOutputMessage() {
                public OutputStream getBody() {
                    return outputStream;
                }

                public HttpHeaders getHeaders() {
                    return headers;
                }
            });
        });
    } else {
        //响应 <--
        this.writeInternal(t, type, outputMessage);
        outputMessage.getBody().flush();
    }

}

==================================== AbstractJackson2XmlHttpMessageConverter =======================================

/**
 * this.writeInternal(t, type, outputMessage);
 * t：person对象
 * type：Person
 * outputMessage：ServletServiceHttpResponse响应信息
 *
 */
protected void writeInternal(Object object, @Nullable Type type, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
    MediaType contentType = outputMessage.getHeaders().getContentType();
    JsonEncoding encoding = this.getJsonEncoding(contentType);
    JsonGenerator generator = this.objectMapper.getFactory().createGenerator(outputMessage.getBody(), encoding);

    try {
        this.writePrefix(generator, object);
        Object value = object;
        Class<?> serializationView = null;
        FilterProvider filters = null;
        JavaType javaType = null;
        if (object instanceof MappingJacksonValue) {
            MappingJacksonValue container = (MappingJacksonValue)object;
            value = container.getValue();
            serializationView = container.getSerializationView();
            filters = container.getFilters();
        }

        if (type != null && TypeUtils.isAssignable(type, value.getClass())) {
            javaType = this.getJavaType(type, (Class)null);
        }

        ObjectWriter objectWriter = serializationView != null ? this.objectMapper.writerWithView(serializationView) : this.objectMapper.writer();
        if (filters != null) {
            objectWriter = objectWriter.with(filters);
        }

        if (javaType != null && javaType.isContainerType()) {
            objectWriter = objectWriter.forType(javaType);
        }

        SerializationConfig config = objectWriter.getConfig();
        if (contentType != null && contentType.isCompatibleWith(MediaType.TEXT_EVENT_STREAM) && config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {
            objectWriter = objectWriter.with(this.ssePrettyPrinter);
        }
		//写操作
        objectWriter.writeValue(generator, value);
        this.writeSuffix(generator, object);
        generator.flush();
    } catch (InvalidDefinitionException var13) {
        throw new HttpMessageConversionException("Type definition error: " + var13.getType(), var13);
    } catch (JsonProcessingException var14) {
        throw new HttpMessageNotWritableException("Could not write JSON: " + var14.getOriginalMessage(), var14);
    }
}

====================================================== ObjectWriter ==========================================

//g：ToXmlGenerator
public void writeValue(JsonGenerator g, Object value) throws IOException {
    this._assertNotNull("g", g);
    this._configureGenerator(g);
    if (this._config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && value instanceof Closeable) {
        Closeable toClose = (Closeable)value;

        try {
            this._prefetch.serialize(g, value, this._serializerProvider());
            if (this._config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {
                g.flush();
            }
        } catch (Exception var5) {
            ClassUtil.closeOnFailAndThrowAsIOE((JsonGenerator)null, toClose, var5);
            return;
        }

        toClose.close();
    } else {
        this._prefetch.serialize(g, value, this._serializerProvider());
        if (this._config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {
            g.flush();
        }
    }

}

```



### 4. 基于请求参数的内容协商原理



上一节内容协商原理的第二步中：

获取客户端（PostMan、浏览器）支持接收的内容类型。（获取客户端Accept请求头字段application/xml）

contentNegotiationManager内容协商管理器 默认使用 HeaderContentNegotiationStrategy基于请求头的内容协商策略



对于上面那种 基于请求头的内容协商策略模式，如果我们是使用Postman，我们可以很方便的修改请求头信息。

如果我们是使用浏览器请求，我们却难以修改请求头信息，为了方便内容协商，我们开启**基于请求参数的内容协商策略** 



#### 开启浏览器参数方式内容协商功能

```yaml
spring:
  mvc:
    contentnegotiation:
      favor-parameter: true  #开启请求参数内容协商策略模式
```

contentNegotiationManager内容协商管理器中，就会多一个 ParameterContentNegotiationStrategy基于请求参数的内容协商策略（由Spring容器注入）

```java
public class ParameterContentNegotiationStrategy extends AbstractMappingContentNegotiationStrategy {
    //参数名
    private String parameterName = "format";

    public ParameterContentNegotiationStrategy(Map<String, MediaType> mediaTypes) {
        super(mediaTypes);
    }

    public void setParameterName(String parameterName) {
        Assert.notNull(parameterName, "'parameterName' is required");
        this.parameterName = parameterName;
    }

    public String getParameterName() {
        return this.parameterName;
    }

    @Nullable
    protected String getMediaTypeKey(NativeWebRequest request) {
        return request.getParameter(this.getParameterName());
    }
}
```

然后，浏览器地址输入带format参数的URL：

```
http://localhost:8888/test/person?format=json
或
http://localhost:8888/test/person?format=xml
```

这样，后端会根据参数format的值，返回对应json或xml格式的数据。



**案例演示**

我们在服务器请求：http://localhost:8888/test/person?format=json



跳到上一节内容协商原理的第二步中：

​	获取客户端（PostMan、浏览器）支持接收的内容类型

```java
====================================== AbstractMessageConverterMethodProcessor =============================

protected <T> void writeWithMessageConverters(@Nullable T value, MethodParameter returnType, ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage) throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {

    ...
        
    	//获取客户端（PostMan、浏览器等）支持接收的内容类型 <--
        List<MediaType> acceptableTypes = this.getAcceptableMediaTypes(request);
    
    ...
}

//this.getAcceptableMediaTypes(request)
private List<MediaType> getAcceptableMediaTypes(HttpServletRequest request) throws HttpMediaTypeNotAcceptableException {
    //contentNegotiationManager内容协商管理器【现在里面已经有两个 内容协商策略了】 <--
    return this.contentNegotiationManager.resolveMediaTypes(new ServletWebRequest(request));

}

============================= ContentNegotiationManager内容协商管理器 ===========================================

public List<MediaType> resolveMediaTypes(NativeWebRequest request) throws HttpMediaTypeNotAcceptableException {
    
    Iterator var2 = this.strategies.iterator();

    //迭代里面的所有内容协商策略【此时第一个策略为 基于请求参数的内容协商策略】
    List mediaTypes;
    do {
        if (!var2.hasNext()) {
            return MEDIA_TYPE_ALL_LIST;
        }

        ContentNegotiationStrategy strategy = (ContentNegotiationStrategy)var2.next();
        //开始解析 浏览器需要响应的内容类型
        mediaTypes = strategy.resolveMediaTypes(request);
    } while(mediaTypes.equals(MEDIA_TYPE_ALL_LIST));

    return mediaTypes;
}

//我们分析 基于请求参数的内容协商策略 解析原理
========================== AbstractMappingContentNegotiationStrategy =====================================
public List<MediaType> resolveMediaTypes(NativeWebRequest webRequest) throws HttpMediaTypeNotAcceptableException {
   	
    //this就是相应的 内容协商策略（ParameterContentNegotiationStrategy基于请求参数的内容协商策略）
    //(a)this.getMediaTypeKey(webRequest)：从请求中获取一个请求参数（基于请求参数的内容协商策略 中的parameterName参数名 为 "format"）
    //(b)this.resolveMediaTypeKey()：就是获取webRequest原生请求中format的值（请求路径中我们拼接的一个请求参数format=json）
    //  所以这个方法 就确定了，浏览器响应需要的媒体内容类型为 application/json
    return this.resolveMediaTypeKey(webRequest, this.getMediaTypeKey(webRequest));

}

//(b)this.resolveMediaTypeKey(webRequest, Key)： 从原生请求中获取，key(format)的值(json)
public List<MediaType> resolveMediaTypeKey(NativeWebRequest webRequest, @Nullable String key)
    throws HttpMediaTypeNotAcceptableException {

    if (StringUtils.hasText(key)) {
        
        // mediaType(application/json)
        MediaType mediaType = lookupMediaType(key);
        if (mediaType != null) {
            handleMatch(key, mediaType);
            return Collections.singletonList(mediaType);
        }
        mediaType = handleNoMatch(webRequest, key);
        if (mediaType != null) {
            addMapping(key, mediaType);
            return Collections.singletonList(mediaType);
        }
    }
    return MEDIA_TYPE_ALL_LIST;
}
```





### 5. 自定义MessageConverter



MessageConverter消息转换器的确定过程：

1. @ResponseBody响应数据出去 调用 RequestResponseBodyMethodProcessor返回值 处理
2. 返回值处理器 处理方法返回值。通过 MessageConverter处理
3. 所有 MessageConverter 合起来 可以支持各种媒体类型数据的操作（读、写）
4. 内容协商找到最终的 messageConverter



现在主流的响应媒体内容类型为 json（application/json） 和 xml（application/xml），这两种类型的数据格式为：

```json
//json类型 的数据格式:
{
    "userName": "zhangsan",
    "age": 28,
    "birth": "2022-12-14T03:40:42.170+00:00",
    "pet": null
}
```

```xml
<!-- xml类型 的数据格式：-->
<Person>
    <userName>zhangsan</userName>
    <age>28</age>
    <birth>2022-12-14T08:14:59.260+00:00</birth>
    <pet/>
</Person>
```

现在我们需要自定义一种 媒体类型 如 x-guigu（application/x-guigu），我们想要这种类型的数据格式为：**属性值1;属性值2;**

```
zhangsan;28;2022-12-14T08:14:59.260+00:00
```



想要添加这种媒体内容类型，就必须添加一种能 支持将它读写的MessageConverter消息转换器



实现自定义内容类型的步骤：

 	1、添加自定义的MessageConverter进系统底层

 	2、系统底层就会统计出所有MessageConverter能操作哪些内容类型 

 	3、客户端内容协商 [guigu <--匹配--> guigu]



**无论我们修改 SpringMVC的什么功能，只有一个入口给容器中添加东西：在配置类的 WebMvcConfigurer中添加**



WebMvcConfigurer是一个接口，里面有两个方法 extendMessageConverters() ,configureMessageConverters()

第一个是扩展消息转换器，在原有的基础上添加新的

第二个是配置消息转换器，他会把默认的消息转换器覆盖



**开始配置：**

```java
@Configuration(proxyBeanMethods = false)
public class WebConfig {
    
    @Bean
    public WebMvcConfigurer webMvcConfigurer(){
        
        return new WebMvcConfigurer() {

            //我们使用扩展的消息转换器方法，加一个新的消息转换器
            @Override
            public void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
                converters.add(new GuiguMessageConverter());
            }
            
        }
        
    }
    
}
```

```java

/**
 * 自定义的Converter
 */
public class GuiguMessageConverter implements HttpMessageConverter<Person> {

    
    @Override
    public boolean canRead(Class<?> clazz, MediaType mediaType) {
        return false;
    }

    //判断是否可以写某种类型的方法，让他支持对Person类型 的写操作
    @Override
    public boolean canWrite(Class<?> clazz, MediaType mediaType) {
        return clazz.isAssignableFrom(Person.class);
    }

    //支持什么样的媒体内容类型，让他支持 application/x-guigu 
    //这样的话，系统在响应Person类型的返回值，收集支持的消息转换器 的支持的媒体内容类型，就会把 application/x-guigu收集进去
    @Override
    public List<MediaType> getSupportedMediaTypes() {
        return MediaType.parseMediaTypes("application/x-guigu");
    }

    @Override
    public Person read(Class<? extends Person> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {
        return null;
    }

    //写出方法，这个方法就是规定响应的数据类型格式 并将他写出去
    @Override
    public void write(Person person, MediaType contentType, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException {
        //自定义协议数据的写出（属性值1;属性值2;）
        String data = person.getUserName()+";"+person.getAge()+";"+person.getBirth();

        //写出去
        OutputStream body = outputMessage.getBody();
        body.write(data.getBytes());
    }
}
```



```java
import java.util.Date;

@Controller
public class ResponseTestController {

    /**
     * 1、浏览器发请求直接返回 xml    [application/xml]                jacksonXmlConverter
     * 2、如果是ajax请求 返回 json   [application/json]               jacksonJsonConverter
     * 3、如果硅谷app发请求，返回自定义协议数据  [appliaction/x-guigu]    xxxxConverter
     *          属性值1;属性值2;
     *
     * 步骤：
     * 1、添加自定义的MessageConverter进系统底层
     * 2、系统底层就会统计出所有MessageConverter能操作哪些类型
     * 3、客户端内容协商 [guigu--->guigu]
     *
     * 作业：如何以参数的方式进行内容协商
     * @return
     */
    @ResponseBody  //利用返回值处理器里面的消息转换器进行处理
    @GetMapping(value = "/test/person")
    public Person getPerson(){
        Person person = new Person();
        person.setAge(28);
        person.setBirth(new Date());
        person.setUserName("zhangsan");
        return person;
    }

}
```



用Postman发送 /test/person （请求头 Accept:application/x-guigu)，将返回自定义协议数据的写出。



### 6. 浏览器与PostMan内容协商完全适配

假设你想 **基于自定义请求参数内容协商策略的自定义内容协商**功能。

换句话，在地址栏输入 http://localhost:8080/test/person?format=gg 返回数据，

跟 http://localhost:8080/test/person 且请求头参数Accept:application/x-guigu 的返回自定义协议数据的一致。



之前我们已经 开启了 基于请求参数的内容协商策略，里面配置好了 application/json和 application/xml 的媒体内容类型

所以想要将 x-guigu也加入到 请求参数策略里面 就需要自定义内容协商管理器

在 配置类的 WebMvcConfigurer中 重写configureContentNegotiation(),修改内容协商策略

```java
@Configuration(proxyBeanMethods = false)
public class WebConfig /*implements WebMvcConfigurer*/ {

    //1、WebMvcConfigurer定制化SpringMVC的功能
    @Bean
    public WebMvcConfigurer webMvcConfigurer(){
        return new WebMvcConfigurer() {

            /**
             * 修改内容协商策略
             * @param configurer
             */
            @Override
            public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
                //Map<String, MediaType> mediaTypes 媒体内容类型
                Map<String, MediaType> mediaTypes = new HashMap<>();
                mediaTypes.put("json",MediaType.APPLICATION_JSON); 	//application/json
                mediaTypes.put("xml",MediaType.APPLICATION_XML); 	//application/xml
                mediaTypes.put("gg",MediaType.parseMediaType("application/x-guigu")); //自定义媒体类型
                //创建一个基于请求头的内容协商策略 （指定支持解析哪些参数对应的哪些媒体类型）
                ParameterContentNegotiationStrategy parameterStrategy = new ParameterContentNegotiationStrategy(mediaTypes);

                //还可以修改参数名 默认是format
                //parameterStrategy.setParameterName("ff");
                
                //还需添加请求头处理内容协商策略，否则accept:application/json、application/xml则会失效
                HeaderContentNegotiationStrategy headeStrategy = new HeaderContentNegotiationStrategy();

                //将两个策略 添加到内容协商管理器中
                configurer.strategies(Arrays.asList(parameterStrategy, headeStrategy));
            }
        }
    }
    
    ...
    
}
```

日后开发要注意，**有可能我们添加的自定义的功能会覆盖默认很多功能，导致一些默认的功能失效。**



## 十、视图解析-Thymeleaf初体验

> **Thymeleaf** is a modern server-side Java template engine for both web and standalone environments.
>
> Thymeleaf's main goal is to bring elegant *natural templates* to your development workflow — HTML that can be correctly displayed in browsers and also work as static prototypes, allowing for stronger collaboration in development teams.
>
> With modules for Spring Framework, a host of integrations with your favourite tools, and the ability to plug in your own functionality, Thymeleaf is ideal for modern-day HTML5 JVM web development — although there is much more it can do.——[Link](https://www.thymeleaf.org/)

[Thymeleaf官方文档](https://www.thymeleaf.org/documentation.html)

### 1. thymeleaf使用

#### (1) 引入Starter

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
```

#### (2) 自动配置好了thymeleaf

```java
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(ThymeleafProperties.class)
@ConditionalOnClass({ TemplateMode.class, SpringTemplateEngine.class })
@AutoConfigureAfter({ WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class })
public class ThymeleafAutoConfiguration {
    ...
}
```

自动配好的内容协商策略

1. 所有thymeleaf的配置值都在 ThymeleafProperties

2. 配置好了 **SpringTemplateEngine** 

3. 配好了 **ThymeleafViewResolver** 

4. 我们只需要直接开发页面

```java
public static final String DEFAULT_PREFIX = "classpath:/templates/";//模板放置处
public static final String DEFAULT_SUFFIX = ".html";//文件的后缀名
```

编写一个控制层：

```java
@Controller
public class ViewTestController {
    @GetMapping("/hello")
    public String hello(Model model){
        //model中的数据会被放在请求域中 request.setAttribute("a",aa)
        model.addAttribute("msg","一定要大力发展工业文化");
        model.addAttribute("link","http://www.baidu.com");
        return "success";
    }
}
```

`/templates/success.html`：

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<h1 th:text="${msg}">nice</h1>
<h2>
    <a href="www.baidu.com" th:href="${link}">去百度</a>  <br/>
    <a href="www.google.com" th:href="@{/link}">去百度</a>
</h2>
</body>
</html>
```

---

```yaml
server:
  servlet:
    context-path: /app #设置应用名
```

这个设置后，URL要插入`/app`,  如`http://localhost:8080/app/hello.html`。

### 2. 基本语法

#### (1) 表达式

| 表达式名字 | 语法   |                用途                |
| ---------- | ------ | :--------------------------------: |
| 变量取值   | ${...} |  获取请求域、session域、对象等值   |
| 选择变量   | *{...} |          获取上下文对象值          |
| 消息       | #{...} |           获取国际化等值           |
| 链接       | @{...} |              生成链接              |
| 片段表达式 | ~{...} | jsp:include 作用，引入公共页面片段 |

#### (2) 字面量

- 文本值: **'one text'** **,** **'Another one!'** **,…**
- 数字: **0** **,** **34** **,** **3.0** **,** **12.3** **,…**
- 布尔值: **true** **,** **false**
- 空值: **null**
- 变量： one，two，.... 变量不能有空格

#### (3) 文本操作

- 字符串拼接: **+**
- 变量替换: **|The name is ${name}|** 

#### (4) 数学运算

- 运算符: + , - , * , / , %

#### (5) 布尔运算

- 运算符:  **and** **,** **or**
- 一元运算: **!** **,** **not** 

#### (6) 比较运算

- 比较: **>** **,** **<** **,** **>=** **,** **<=** **(** **gt** **,** **lt** **,** **ge** **,** **le** **)**
- 等式: **==** **,** **!=** **(** **eq** **,** **ne** **)** 

#### (7) 条件运算

- If-then: **(if) ? (then)**
- If-then-else: **(if) ? (then) : (else)**
- Default: (value) **?: (defaultvalue)** 

#### (8) 特殊操作

- 无操作： _

	

### 3. 设置属性值-th:attr

- 设置单个值

```html
<form action="subscribe.html" th:attr="action=@{/subscribe}">
  <fieldset>
    <input type="text" name="email" />
    <input type="submit" value="Subscribe!" th:attr="value=#{subscribe.submit}"/>
  </fieldset>
</form>
```

- 设置多个值

```html
<img src="../../images/gtvglogo.png"  
     th:attr="src=@{/images/gtvglogo.png},title=#{logo},alt=#{logo}" />
```

[官方文档 - 5 Setting Attribute Values](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#setting-attribute-values)



### 4. 迭代

```html
<tr th:each="prod : ${prods}">
    <td th:text="${prod.name}">Onions</td>
    <td th:text="${prod.price}">2.41</td>
    <td th:text="${prod.inStock}? #{true} : #{false}">yes</td>
</tr>
```

```html
<tr th:each="prod,iterStat : ${prods}" th:class="${iterStat.odd}? 'odd'">
    <td th:text="${prod.name}">Onions</td>
    <td th:text="${prod.price}">2.41</td>
    <td th:text="${prod.inStock}? #{true} : #{false}">yes</td>
</tr>
```

### 5. 条件运算

```html
<a href="comments.html"
	th:href="@{/product/comments(prodId=${prod.id})}"
	th:if="${not #lists.isEmpty(prod.comments)}">view</a>
```

```html
<div th:switch="${user.role}">
      <p th:case="'admin'">User is an administrator</p>
      <p th:case="#{roles.manager}">User is a manager</p>
      <p th:case="*">User is some other thing</p>
</div>
```

### 6. 属性优先级

| Order | Feature                         | Attributes                                 |
| :---- | :------------------------------ | :----------------------------------------- |
| 1     | Fragment inclusion              | `th:insert` `th:replace`                   |
| 2     | Fragment iteration              | `th:each`                                  |
| 3     | Conditional evaluation          | `th:if` `th:unless` `th:switch` `th:case`  |
| 4     | Local variable definition       | `th:object` `th:with`                      |
| 5     | General attribute modification  | `th:attr` `th:attrprepend` `th:attrappend` |
| 6     | Specific attribute modification | `th:value` `th:href` `th:src` `...`        |
| 7     | Text (tag body modification)    | `th:text` `th:utext`                       |
| 8     | Fragment specification          | `th:fragment`                              |
| 9     | Fragment removal                | `th:remove`                                |

[官方文档 - 10 Attribute Precedence](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#attribute-precedence)



## 十一、web实验-后台管理系统



### 1. 后台管理系统基本功能



#### (1) 项目创建

使用IDEA的Spring Initializr。

- thymeleaf、
- web-starter、
- devtools、
- lombok

#### (2) 登陆页面

- `/static` 放置 css，js等静态资源

- `/templates/login.html` 登录页

```html
<html lang="en" xmlns:th="http://www.thymeleaf.org"><!-- 要加这玩意thymeleaf才能用 -->

<form class="form-signin" action="index.html" method="post" th:action="@{/login}">

    ...
    
    <!-- 消息提醒 -->
    <label style="color: red" th:text="${msg}"></label>
    
    <input type="text" name="userName" class="form-control" placeholder="User ID" autofocus>
    <input type="password" name="password" class="form-control" placeholder="Password">
    
    <button class="btn btn-lg btn-login btn-block" type="submit">
        <i class="fa fa-check"></i>
    </button>
    
    ...
    
</form>
```

- `/templates/main.html` 主页

thymeleaf内联写法：

```html
<p>Hello, [[${session.user.name}]]!</p>
```

#### (3) 登录控制层

```java
@Controller
public class IndexController {
    /**
     * 来登录页
     * @return
     */
    @GetMapping(value = {"/","/login"})
    public String loginPage(){

        return "login";
    }

    @PostMapping("/login")
    public String main(User user, HttpSession session, Model model){ //RedirectAttributes

        if(StringUtils.hasLength(user.getUserName()) && "123456".equals(user.getPassword())){
            //把登陆成功的用户保存起来
            session.setAttribute("loginUser",user);
            //登录成功重定向到main.html;  重定向防止表单重复提交
            return "redirect:/main.html";
        }else {
            model.addAttribute("msg","账号密码错误");
            //回到登录页面
            return "login";
        }
    }
    
     /**
     * 去main页面
     * @return
     */
    @GetMapping("/main.html")
    public String mainPage(HttpSession session, Model model){
        
        //最好用拦截器,过滤器
        Object loginUser = session.getAttribute("loginUser");
        if(loginUser != null){
        	return "main";
        }else {
            //session过期，没有登陆过
        	//回到登录页面
	        model.addAttribute("msg","请重新登录");
    	    return "login";
        }
    }
    
}
```



#### (4) 模型

```java
@AllArgsConstructor
@NoArgsConstructor
@Data
public class User {
    private String userName;
    private String password;
}
```



### 2. 抽取公共页面

[官方文档 - Template Layout](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#template-layout)

- 公共页面`/templates/common.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"><!--注意要添加xmlns:th才能添加thymeleaf的标签-->
<head th:fragment="commonheader">
    <!--common-->
    <link href="css/style.css" th:href="@{/css/style.css}" rel="stylesheet">
    <link href="css/style-responsive.css" th:href="@{/css/style-responsive.css}" rel="stylesheet">
    ...
</head>
<body>
<!-- left side start-->
<div id="leftmenu" class="left-side sticky-left-side">
	...

    <div class="left-side-inner">
		...

        <!--sidebar nav start-->
        <ul class="nav nav-pills nav-stacked custom-nav">
            <li><a th:href="@{/main.html}"><i class="fa fa-home"></i> <span>Dashboard</span></a></li>
            ...
            <li class="menu-list nav-active"><a href="#"><i class="fa fa-th-list"></i> <span>Data Tables</span></a>
                <ul class="sub-menu-list">
                    <li><a th:href="@{/basic_table}"> Basic Table</a></li>
                    <li><a th:href="@{/dynamic_table}"> Advanced Table</a></li>
                    <li><a th:href="@{/responsive_table}"> Responsive Table</a></li>
                    <li><a th:href="@{/editable_table}"> Edit Table</a></li>
                </ul>
            </li>
            ...
        </ul>
        <!--sidebar nav end-->
    </div>
</div>
<!-- left side end-->


<!-- header section start-->
<div th:fragment="headermenu" class="header-section">

    <!--toggle button start-->
    <a class="toggle-btn"><i class="fa fa-bars"></i></a>
    <!--toggle button end-->
	...

</div>
<!-- header section end-->

<div id="commonscript">
    <!-- Placed js at the end of the document so the pages load faster -->
    <script th:src="@{/js/jquery-1.10.2.min.js}"></script>
    <script th:src="@{/js/jquery-ui-1.9.2.custom.min.js}"></script>
    <script th:src="@{/js/jquery-migrate-1.2.1.min.js}"></script>
    <script th:src="@{/js/bootstrap.min.js}"></script>
    <script th:src="@{/js/modernizr.min.js}"></script>
    <script th:src="@{/js/jquery.nicescroll.js}"></script>
    <!--common scripts for all pages-->
    <script th:src="@{/js/scripts.js}"></script>
</div>
</body>
</html>
```



- `/templates/table/basic_table.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="ThemeBucket">
  <link rel="shortcut icon" href="#" type="image/png">

  <title>Basic Table</title>
    <div th:include="common :: commonheader"> </div><!--将common.html的代码段 插进来-->
</head>

<body class="sticky-header">

<section>
<div th:replace="common :: #leftmenu"></div>
    
    <!-- main content start-->
    <div class="main-content" >

        <div th:replace="common :: headermenu"></div>
        ...
    </div>
    <!-- main content end-->
</section>

<!-- Placed js at the end of the document so the pages load faster -->
<div th:replace="common :: #commonscript"></div>


</body>
</html>

```

[Difference between `th:insert` and `th:replace` (and `th:include`)](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#difference-between-thinsert-and-threplace-and-thinclude)



### 3. 遍历数据与页面bug修改

控制层代码：

```java
@GetMapping("/dynamic_table")
public String dynamic_table(Model model){
    //表格内容的遍历
    List<User> users = Arrays.asList(new User("zhangsan", "123456"),
                                     new User("lisi", "123444"),
                                     new User("haha", "aaaaa"),
                                     new User("hehe ", "aaddd"));
    model.addAttribute("users",users);

    return "table/dynamic_table";
}
```

页面代码：

```html
<table class="display table table-bordered" id="hidden-table-info">
    <thead>
        <tr>
            <th>#</th>
            <th>用户名</th>
            <th>密码</th>
        </tr>
    </thead>
    <tbody>
        <tr class="gradeX" th:each="user,stats:${users}">
            <td th:text="${stats.count}">Trident</td>
            <td th:text="${user.userName}">Internet</td>
            <td >[[${user.password}]]</td>
        </tr>
    </tbody>
</table>
```



